# 第一章 预备知识

C++总览简介

C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。
C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。
C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。
C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。

注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。

面向对象程序设计

C++最大的亮点就是面向对象程序设计理念的运用。包括面向对象开发的四大特性：
    封装
    抽象
    继承
    多态

C++的组成部分

标准的 C++ 由三个重要部分组成：
    核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。
    C++ 标准库，提供了大量的函数，用于操作文件、字符串等。
    标准模板库（STL），提供了大量的方法，用于操作数据结构等。



# 第二章 开始学习 C++
（略）
C++用分号隔开每一个执行语句。
# 第三章 处理数据

**面向对象编程（OOP）的本质是设计并扩展自己的数据类型。设计自己的数据类型就是让类型与数据匹配。**

内置的C++类型分两组：基本类型和复合类型。本章将介绍基本类型，即整数和浮点数。似乎只有两种类型，但C++知道，没有任何一种整型和浮点型能够满足所有的编程要求，因此对于这两种数据，它提供 了多种变体。

## 3.1 简单变量

把信息存储在计算机中，程序必须记录3个基本属性：

* 信息将存储在哪里； 
* 要存储什么值； 
* 存储何种类型的信息。

实际上，程序将找到一块能够存储整数的内存，将该内存单元标记为braincount，并将5复制到该内存单元中；然 后，您可在程序中使用braincount来访问该内存单元。

> 可以使用&运算符来检索braincount的内存地址。

### 3.1.1 变量名

C++ 提倡使用有一定含义的变量名，并遵循几 种简单的 C++ 命名规则：

* 在名称中只能使用字母字符、数字和下划线 ( _ )；
* 名称的第一个字符不能是数字；
* 区分大写字符与小写字符；
* 不能将C++关键字用作名称；
* 以*两个下划线* 或 *下划线+大写字母* 打头的名称被保留给实现（编译器及其使用的资源）使用；
* 以 *一个下划线* 开头的名称被保留给实现，用作全局标识符；

C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。

> 倒数第二点与前面几点有些不同，因为使用像 __time_stop 或 _Donut 这样的名称不会导致编译器错误，而会导致行为的不确定性。换句话说，不知道结果将是什么。不出现编译器错误的原因是，这样的名称不 是非法的，但要留给实现使用。

![image-20210719213322578](https://static.fungenomics.com/images/2021/07/image-20210719213322578.png)

如果想用两个或更多的单词组成一个名称，通常的做法是用下划线字符将单词分开，如 my_onions (**用这类**)；或者从第二个单词开始将每个单词的第一个字母大写，如 myEyeTooth。

**在 C++ 所有主观的风格中，一致性和精度是最重要的**。请根据自己的需要、喜好和个人风格来使用变量名（或必要时，根据雇主的需要、喜好和个人风格来选择变量名）。

### 3.1.2 整型

不同C++整型使用不同的内存量来存储整数。使用的内存量越大，可以表示的整数值范围也越大。

C++的基本整型（按宽度递增的顺序排列）分别是char、short、int、long和C++11新增的long long，其中每种类型都有符号版本和无符号版本，因此总共有10种类型可供选择。

### 3.1.3 整型short、int、long和long long

C++ 的short、int、long和long long类型通过使用不同数目的位来存储值，最多能够表示4种不同的整数宽度：

* short至少16位；
* int至少与short一样长；
* long 至少32位，且至少与int一样长；
* long long至少64位，且至少与long一样长。

> 这意味着可以把16位单元设置成65 536个不同的值，把 32位单元设置成4 294 672 296个不同的值，把64位单元设置为18 446 744 073 709 551 616个不同的值。作为比较，unsigned long存储不了地球上当前的人数和银河系的星星数，而long long 能够。

当前很多系统都使用最小长度，即short为16位，long为32位。这仍然为int提供了多种选择，其宽度可以是16位、24位或32位，同时又符合标准；甚至可以是64位，因为long和long long至少长64位。

> 类型的宽度随实现而异，这可能在将C++程序从一种环境移到另一种环境（包括在同一个系统中使用不同编译器）时引发问题。

首先，sizeof运算符返回类型或变量的长度；其次，头文件climits（在老式实现中为limits.h）中包含了关于整型限制的信息。具体地说，它定义了表示各种限制的符号名称。例如，INT_MAX为int的最大取值，CHAR_BIT为字节的位数。

在我的 Macbook Air 64位 OS 上，数据类型是这样的: 

```bash
int is 4 bytes.
short is 2 bytes.
long is 8 bytes.
long long is 8 bytes.

Maximum values:
int: 2147483647
short: 32767
long: 9223372036854775807
long long: 9223372036854775807

Minimum int value = -2147483648
Bits per byte = 8
```

![image-20210719215348315](https://static.fungenomics.com/images/2021/07/image-20210719215348315.png)
![image-20210719215405073](https://static.fungenomics.com/images/2021/07/image-20210719215405073.png)

**赋值与声明合并在一起叫做初始化。**如果知道变量的初始值应该是什么，则应对它进行初始化。

如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该变量的值 将是它被创建之前，相应内存单元保存的值。

![image-20210719215954131](https://static.fungenomics.com/images/2021/07/image-20210719215954131.png)


### 3.1.4 无符号类型

要创建无符号版 本的基本整型，只需使用关键字 unsigned 来修改声明即可。注意，unsigned本身是unsigned int的缩写。

### 3.1.5 选择整型类型

通常，int被设置为对 目标计算机而言最为“自然”的长度。自然长度（natural size）指的是计 算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其 他类型，则应使用int。

如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long。即使系统上int为32位，也应这样做。这样，将程序移植到16位系统时，就不会突然无法正常工作（参见图3.2）。如果要存储的值超过20亿，可使用long long。

> 所以对于基因组数据上的位置信息，最好是 long 类型咯，即便 unsigned int 类型已经足够。（不过我可能还是希望用 unsigned int ）

![image-20210719220858422](https://static.fungenomics.com/images/2021/07/image-20210719220858422.png)

如果short比int小，则使用short可以节省内存。通常，仅当有大型整 型数组时，才有必要使用short。如果只需要一个字节，可使用char。

### 3.1.6 整型字面值

整型字面值（常量）是显式地书写的常量，如212或1776。

> 诸如cout<<hex;等代码不会在屏幕上显示任何内容，而只是修改 cout显示整数的方式。因此，控制符hex实际上是一条消息，告诉cout采 取何种行为。另外，由于标识符hex位于名称空间std中，而程序使用了 该名称空间，因此不能将hex用作变量名。然而，如果省略编译指令 using，而使用std::cout、std::endl、std::hex和std::oct，则可以将hex用作 变量名。

### 3.1.7 C++如何确定常量的类型

![image-20210719221757664](https://static.fungenomics.com/images/2021/07/image-20210719221757664.png)

### 3.1.8 char类型：字符和小整数

char类型是专为存 储字符（如字母和数字）而设计的。

char类型是另一种整型。实际上，很多系统支持的字符都不超过128个，因此用一个字节就可以表示所有的符号。因此，虽然char最常被用来处理字符，但也可以 将它用做比short更小的整型。

C++对字符用单引号，对字符串使用双引号。 cout对象能够处理这两种情况，但正如第4章将讨论的，这两者有天壤之别）。

与int不同的是，char在默认情况下既不是没有符号，也不是有符号。是否有符号由C++实现决定，这样编译器开发人员可以最大限度地将这种类型与硬件属性匹配起来。如果char有某种特定的行为对您来说 非常重要，则可以显式地将类型设置为signed char 或unsigned char。

如果将char用作数值类型，则unsigned char和signed char之间的差异将非常重要。unsigned char类型的表示范围通常为0～255，而signed char 的表示范围为−128到127。

> 例如，假设要使用一个char变量来存储像200这样大的值，则在某些系统上可以，而在另一些系统上可能不可以。但 使用unsigned char可以在任何系统上达到这种目的。

如果大型字符 集是实现的基本字符集(如中文日文系统)，则编译器厂商可以将char定义为一个16位的字节或更长的字节。其次，一种实现可以同时支持一个小型基本字符集和 一个较大的扩展字符集。8位char可以表示基本字符集，另一种类型 wchar_t（宽字符类型）可以表示扩展字符集。wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类 型与另一种整型（底层（underlying）类型）的长度和符号属性相同。对底层类型的选择取决于实现，因此在一个系统中，它可能是unsigned short，而在另一个系统中，则可能是int。



## 3.2 const 限定符

C++有一种比 `#define` 更好的处理符号常量的方法，这种方法就是使用 const 关键字来修改变量声明和初始化。

```Cpp
const int Months = 12;
```
常量（如Months）被初始化后，其值就被固定 了，编译器将不允许再修改该常量的值。如果您这样做，g++将指出程 序试图给一个只读变量赋值。关键字const叫做限定符，因为它限定了声 明的含义。

> #define 定义符号常量的方式应抛弃。

一种常见的做法是将名称的首字母大写，以提醒您Months是个常量。这决不是一种通用约定，但在阅读程序时有助于区分常量和变量。另一种约定是将整个名称大写，使用#define创建常量时通常使用这种约定。

**注意：** 如果在声明常量时没有提供值，则该常量的值将是不确定的，且无 法修改。

## 3.3 浮点数

使用浮点类型可以表示诸如2.5、3.14159和122442.32这样的数字，即带小数部分的数字。计算机将这样的值分成两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。下面打个比方。对于数字34.1245和34124.5，它们除了小数点的位置不同外，其他都是相同的。 可以把第一个数表示为0.341245（基准值）和100（缩放因子），而将第二个数表示为0.341245（基准值相同）和10000（缩放因子更大）。缩放因子的作用是移动小数点的位置，术语浮点因此而得名。C++内部表示浮点数的方法与此相同，只不过它基于的是二进制数，因此缩放因 子是2的幂，不是10的幂。

### 3.3.1 书写浮点数

C++有两种书写浮点数的方式：
* 第一种是使用常用的标准小数点表示法；
* 第二种表示浮点值的方法叫做E表示法，其外观是像这样的： 3.45E6，这指的是3.45与1000000相乘的结果；E6指的是10的6次方，即 1后面6个0。因此，3.45E6表示的是3450000，6被称为指数，3.45被称为 尾数。

![image-20210719225234354](https://static.fungenomics.com/images/2021/07/image-20210719225234354.png)

E表示法确保数字以浮点格式存储，即使没有小数点。注意，既可 以使用E也可以使用e，指数可以是正数也可以是负数，不要有空格。

![image-20210719224852195](https://static.fungenomics.com/images/2021/07/image-20210719224852195.png)

> 电子的质量是 9.11e-31 kg 表示 0.000000000000000000000000000000911 kg， 而美国报警电话 911 竟然很巧合地与此相同。

### 3.3.2 浮点类型

C++也有3种浮点类型：float、double 和 long double。

事实上，C和C++对于有效位数的要求是，float至少32位，double至少48位，且不少于float，long double至少和double一样多。这三种类型的有效位数可以一样多。然而，通常，float为32位，double为64位， long double为80、96或128位。另外，这3种类型的指数范围至少是−37到37。可以从头文件cfloat或float.h中找到系统的限制。

### 3.3.3 浮点常量

在默认情况下，像8.24和2.4E8这样的浮点常量都属于double类型。如果希望常量为float类型，请使用f或F后缀。对于long double类型，可使用l或L后缀（由于l看起来像数字1，因此L是更好的选择）。

### 3.3.4 浮点数的优缺点

与整数相比，浮点数有两大优点。首先，可以表示整数之间的 值。其次，由于有缩放因子，它们可以表示的范围大得多。另一方面， **浮点运算的速度通常比整数运算慢，且精度将降低**。

如: 2.34E+22是一个小数点左边有23位的数字。加上1，就 是在第23位加1。但float类型只能表示数字中的前6位或前7位，因此修改第23位对这个值不会有任何影响。

## 3.4 C++算术运算符

![image-20210719230134697](https://static.fungenomics.com/images/2021/07/image-20210719230134697.png)

`11.17 + 50.25` 应等于61.42，但是输出的却是61.419998。这不是运算问题，而是由于float类型表示有效位数的能力有限。记住，对于float，C++只保证6位有效位。如果将 61.419998四舍五入成6位，将得到61.4200，这是在保证精度下的正确值，如果用double 则精度足够，所以直接可以获得 61.42 的值。

> 通常来说 double 都比 float 更精准，应尽量使用 double。

### 3.4.1 运算符优先级和结合性

算术运算符遵 循通常的代数优先级，先乘除，后加减。

### 3.4.2 除法分支

除法运算符（/）的行为取决于操作数的类型。如果两个操作数都 是整数，则C++将执行整数除法。这意味着结果的小数部分将被丢弃， 使得最后的结果是一个整数。**如果其中有一个（或两个）操作数是浮点 值，则小数部分将保留，结果为浮点数**。

![image-20210719230953958](https://static.fungenomics.com/images/2021/07/image-20210719230953958.png)

**浮点常量在默认情况下为 double类型。**

### 3.4.3 求模运算符

求模运算符返回整数除法的余数。它与整数除 法相结合，尤其适用于解决要求将一个量分成不同的整数单元的问题。

### 3.4.4 类型转换

由于有11种整型和3种浮点类型，因此计算机需 要处理大量不同的情况，C++自动执行很多类型转换：

* 将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进 行转换； 
* 表达式中包含不同的类型时，C++将对值进行转换；
* 将参数传递给函数时，C++将对值进行转换。

C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将 被转换为接收变量的类型。例如，假设so_long的类型为long，thirty的类 型为short。

将一个值赋给值取值范围更大的类型通常不会导致什么问题。如，将short值赋给long变量并不会改变这个值，只是占用的字节更多而 已。然而，将一个很大的long值（如2111222333）赋给float变量将降低 精度。因为float只有6位有效数字，因此这个值将被四舍五入为 2.11122E9。因此，有些转换是安全的，有些则会带来麻烦。

![image-20210719232005071](https://static.fungenomics.com/images/2021/07/image-20210719232005071.png)

如下的报错是一个可能:

![image-20210719232233106](https://static.fungenomics.com/images/2021/07/image-20210719232233106.png)

将0赋给bool变量时，将被转换为false；而非零值将被转换为true。

当同一个表达式中包含两种不同的算术类型时，将出现什么情况 呢？在这种情况下，C++将执行两种自动转换：首先，一些类型在出现 时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时 将被转换。

* 在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int。具体地说，true被转换为1，false 被转换为0。这些转换被称为整型提升（integral promotion）。

![image-20210719232513015](https://static.fungenomics.com/images/2021/07/image-20210719232513015.png)

> int 是一种最自然的类型，运算速度也最快，要主用。

* 同样，wchar_t被提升成为下列类型中第一个宽度足够存储wchar_t 取值范围的类型：int、unsigned int、long或unsigned long。

* 将不同类型进行算术运算时，也会进行一些转换，例如将int和float 相加时。**当运算涉及两种类型时，较小的类型将被转换为较大的类型。**

![image-20210719232833549](https://static.fungenomics.com/images/2021/07/image-20210719232833549.png)

* 传递参数时的类型转换通常由C++函数原型控制。
* C++还允许通过强制类型转换机制显式地进行类型转换。强制类型转换 的格式有两种。如下：

![image-20210719233243273](https://static.fungenomics.com/images/2021/07/image-20210719233243273.png)

![image-20210719233319788](https://static.fungenomics.com/images/2021/07/image-20210719233319788.png)

**新格式的想法 是，要让强制类型转换就像是函数调用。这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。**

更安全的转换方式是使用 `static_cast<typeName> (value)` 函数。

Stroustrup认为，C语言式的强制类型转换由于有过多的可能性而极 其危险，这将在第15章更深入地讨论。运算符 `static_cast<>` 比传统强制 类型转换更严格。

### 3.4.5 C++11中的auto声明

在初始化声明中，如果 使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成 与初始值相同。

![image-20210719234008239](https://static.fungenomics.com/images/2021/07/image-20210719234008239.png)

![image-20210719234059088](https://static.fungenomics.com/images/2021/07/image-20210719234059088.png)

## 3.5 总结

C++的基本类型分为两组：一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。整型之间通过存储值时使用的内存量及有无符号来区分。整型从最小到最大依次是：bool、char、signed char、 unsigned char、short、unsigned short、int、unsigned int、long、unsigned long以及C++11新增的long long和unsigned long long。还有一种wchar_t 类型，它在这个序列中的位置取决于实现。C++11新增了类型char16_t 和char32_t，它们的宽度足以分别存储16和32位的字符编码。C++确保了char足够大，能够存储系统基本字符集中的任何成员，而wchar_t则可以存储系统扩展字符集中的任意成员，short至少为16位，而int至少与short一样长，long至少为32位，且至少和int一样长。确切的长度取决于 实现。

浮点类型可以表示小数值以及比整型能够表示的值大得多的值。3种浮点类型分别是float、double和long double。C++确保float不比double 长，而double不比long double长。通常，float使用32位内存，double使用 64位，long double使用80到128位。

对变量赋值、在运算中使用不同类型、使用强制类型转换时，C++将把值从一种类型转换为另一种类型。


# 第四章 复合类型

本章需要掌握的内容为:

- 创建和使用数组；
- 创建和使用C-风格字符串；
- 创建和使用 string 类字符串；
- 使用方法 getline() 和 get() 读取字符串；
- 混合输入字符串和数字；
- 创建和使用结构体；
- 创建和使用共用体；
- 创建和使用枚举类型；
- 创建和使用指针；
- 使用 new 和 delete 管理动态内存；
- 创建动态数组；
- 创建动态结构；
- 自动存储、静态存储和动态存储；
- vector 和 array 类简介。

## 4.1 数组

数组（array) 是一种数据格式，能够存储多个**同类型**的值。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。

> 即一个数组所在的内存区域是连续的。

要创建数组，可使用声明语句。数组声明应指出以下三点： 

- 存储在每个元素中的值的类型； 
- 数组名； 
- 数组中的元素数。

在C++中，通过在简单变量后面添加中括号（其中包含 元素数目）来完成数组声明。而数组中的每一个元素都看作是一个简单变量。声明数组的通用格式为 : 

`typeName arrayName[arraySize]`

表达式arraySize指定元素数目，它必须是整型常数（如10）或const 值，也可以是常量表达式（如8 * sizeof（int）），即其中所有的值在编 译时都是已知的。具体说，arraySize不能是变量，变量的值是在程序 运行时设置的。如：

```Cpp
int months[12];   // 声明一个包含 12 个整数的数组
```

C++ 通过使用下标来访问数组中的每一个元素，C++ 数据从0开始编号，数组总长度-1 是最后一个元素，如上：months[0] 为第一个元素，months[11] 是最后一个元素。

![image-20210721153711828](https://static.fungenomics.com/images/2021/07/image-20210721153711828.png)

### 4.1.1 

C++可以在声明语句中初始化数组，只需提供一个用逗号分隔的值列表（初始化列表），并将它们用花 括号括起即可。如 ：

```Cpp
int yamcosts[3] = {20, 30, 5};
```
如果没有初始化数组的值，则其元素值将是不确定的，这意味着元素的值为以前驻留在该内 存单元中的值。

> 将sizeof运算符用于数组名，得到的将是整个数组 中的字节数。

### 4.1.2 数组的初始化规则

只有在定义数组时才能使用初始化，此后就不能使用了，**也不能将一个数组赋给另一个数组**：

![image-20210721154858602](https://static.fungenomics.com/images/2021/07/image-20210721154858602.png)

> 这个方式和 Python 完全不同，原因可能是 Python 以引用为基础赋值，C++此处则是值赋值，只能一个一个来（声明时除外）。

但此后，仍然可以通过下标分别给数组中的元素赋值。注意，**这里是赋值不再是初始化**。

初始化数组时，提供的值可以少于数组的元素数目，编译器将把其他元素设置为 0。因此，将数组中所有的元素都初始化为0非常简单—只要显式地将第 一个元素初始化为0，然后编译器会自动将其他元素都初始化为0。

*还有一种方法，如果初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个 数。但这是很糟糕的做法，不提倡，不举例。*

### 4.1.3 C++11数组初始化方法

数组以前就可使用列表初始化， 但C++11中的列表初始化新增了一些功能。

- 首先，初始化数组时，可省略等号（=）；
- 其次，可不在大括号内包含任何东西，这将把所有元素都设置为零；
- 第三，列表初始化禁止缩窄转换。

![image-20210721160721085](https://static.fungenomics.com/images/2021/07/image-20210721160721085.png)

在上述代码中，第一条语句不能通过编译，因为将浮点数转换为整 型是缩窄操作，即使浮点数的小数点后面为零。第二条语句也不能通过 编译，因为1122011超出了char变量的取值范围（这里假设char变量的长 度为8位）。第三条语句可通过编译，因为虽然112是一个int值，但它在 char变量的取值范围内。

## 4.2 字符串

字符串是存储在内存的一片连续字节中的一系列字符，这里的**连续**是重点。
存储在连续字节中的一系列字符意味着可以将字符串存储在char数 组中，其中每个字符都位于自己的数组元素中。字符串提供了一种存储 文本信息的便捷方式。本章介绍两种处理字符串的方法：（1）C-风格字符串；（2）基于 string 类的方法。

C-风格字符串具有 一种特殊的性质：以空字符（null character）结尾，空字符被写作 \0， 其ASCII码为0，用来标记字符串的结尾。

![image-20210721161457763](https://static.fungenomics.com/images/2021/07/image-20210721161457763.png)

这两个数组都是char数组，但只有第二个数组是字符串，空字符对 C-风格字符串而言至关重要。C++有很多处理字符串的函数，其 中包括cout使用的那些函数。它们都逐个地处理字符串中的字符，直到 到达空字符为止。如果使用cout显示上面的cat这样的字符串，则将显示 前7个字符，发现空字符后停止。使用cout显示上面的dog数 组（它不是字符串），cout将打印出数组中的8个字母，并接着将内存 中随后的各个字节解释为要打印的字符，直到遇到空字符为止（因此不加空字符是C-风格字符串中极其危险的行为）。

有一种更好的、 将字符数组初始化为字符串的方法—只需使用一个用引号括起的字符串 即可，这种字符串被称为字符串常量（string constant）或字符串字面值 （string literal），如下所示：

![image-20210721162122919](https://static.fungenomics.com/images/2021/07/image-20210721162122919.png)

用引号括起来的字符串**隐式**地包括结尾的空字符，因此不用显式地包括它。

最需要注意的是，**使用C-风格字符串，在确定存储字符串所需的最短数组时，别忘了+1，要将结尾的空字符计算在内**。

![image-20210721162704816](https://static.fungenomics.com/images/2021/07/image-20210721162704816.png)

![image-20210721162840015](https://static.fungenomics.com/images/2021/07/image-20210721162840015.png)

> 这里的赋值改为：`char shirt_size[2] = "S";`  才是正确的。

### 4.2.1 拼接字符串常量

事实上，任何两个由空 白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。 因此，下面所有的输出语句都是等效的：

![image-20210721163221414](https://static.fungenomics.com/images/2021/07/image-20210721163221414.png)

注意，拼接时不会在被连接的字符串之间添加空格，第二个字符串 的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后 面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。

### 4.2.2 在数组中使用字符串

从程序清单4.2中可以学到什么呢？
首先，sizeof运算符指出整个数组的长度：15字节，但 strlen( )函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。
另外，strlen( ) 只计算可见的字符，而不把空字符计算在内。因此，对于Basicman，返回的值为8，而不是 9。如果cosmic是字符串，则要存储该字符串，数组的长度不能短于strlen（cosmic）+1。
由于name1和name2是数组，所以可以用索引来访问数组中各个字符。例如，该程序使用 name1[0]找到数组的第一个字符。另外，该程序将name2[3]设置为空字符。这使得字符串在第 3个字符后即结束，虽然数组中还有其他的字符（参见图4.3）。

![image-20210721164300455](https://static.fungenomics.com/images/2021/07/image-20210721164300455.png)

程序清单 4.2 使用 cin 暗含两个问题:

- 遇到空格结束；
- 输入字符串长于目标数组。

### 4.2.3 字符串输入

cin是如何确定已完成字符串输入呢？由于不能通过键盘输入空字 符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白 （空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在 获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串 放到数组中，并自动在结尾添加空字符。

这个例子的实际结果是，cin把Alistair作为第一个字符串，并将它 放到name数组中。这把Dreeb留在输入队列中。当cin在输入队列中搜索 用户喜欢的甜点时，它发现了Dreeb，因此cin读取Dreeb，并将它放到 dessert数组中。

![image-20210721171126781](https://static.fungenomics.com/images/2021/07/image-20210721171126781.png)

另一个问题是，输入字符串可能比目标数组长（运行中没有揭示出 来）。像这个例子一样使用cin，确实不能防止将包含30个字符的字符 串放到20个字符的数组中的情况发生。

文章将这个问题的系统处理留到第 17 章，但下文也能解决。

### 4.2.4 每次读取一行字符串输入

每次读取一个单词通常不是最好的选择。具体地说，需要采用面向行而不是面向单词的方法。istream中的类（如 cin）提供了一些面向行的类成员函数：`getline()` 和 `get()`。这两个函数都读取一 行输入，直到到达换行符（回车符）。区别是，`getline()` 将读入并丢弃换行符，而 `get()` 则将换行符保留在输入队列中。**注意是还保留在输入流里，没有被读走！**

1．面向行的输入：getline( )

getline( )函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。通过 `cin.getline()` 调用。该函数有两个参数，第一个参数是存储输入行的数组名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符或者碰到换行符为止，并自动在结尾处添加空字符。如：

```Cpp
cin.getline(array_name, 20);
```

例子程序清单 4.4:

![image-20210722004651618](https://static.fungenomics.com/images/2021/07/image-20210722004651618.png)

![image-20210722004809212](https://static.fungenomics.com/images/2021/07/image-20210722004809212.png)

2．面向行的输入：get( )

`iostream` 中的 `get()` 虽然和 `getline()` 类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但 get 将换行符保留在输入队列中，假设我们连续两次 调用 `get( )` 那么要注意了。

第一次调用后，换行符将被留在输入队列中，因此第二次调用时看到的第一个字符便是换行符，此时 `get()` 以为已经到达行尾了，而没有发现任何可读取的内容。**如果不借助于帮助，`get()` 将不能跨过该换行符**。

这时要用 `get()` 的另一种变体——不带任何参数，可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。例子：

![image-20210722005755295](https://static.fungenomics.com/images/2021/07/image-20210722005755295.png)

由于 `cin.get(name, ArSize)` 返回的还是 cin 对象，因此还可以合并起来调用：

```Cpp
cin.get(name, ArSize).get();  // 这样也能同时将末尾的换行符读走
```
但风险就是，**假如 ArSize 小于一行的字符数，那么调用 `get()` 后就会发生字符丢失**。

`getline()` 成员函数也同样可以合并调用连续读取字符串：

```Cpp
cin.getline(name1, ArSize).getline(name2, ArSize);
```

这语句将把输入中 连续的两行分别读入到数组name1和name2 中，其效果与两次调用 `cin.getline()` 相同。

为什么要使用 `get()`，而不是 `getline()` 呢？
首先，老式实现没有 `getline()`。其次，`get()` 使输入更仔细。例如，假设用`get( )` 将一行读入数组中。**如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？** （getline，判断不了）， 查看下一个输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入。

总之， `getline()` 使用起来简单一些，但 `get( )` 使得检查错误更简单些。

3．空行和其他问题

当 `getline()` 或 `get()` 读取空行时，将发生什么情况？最初的做法是， 下一条输入语句将在前一条 `getline()` 或 `get()` 结束读取的位置开始读取； 但当前的做法是，当 `get()`（不是getline）读取空行后将设置失效位 （failbit）。这意味着接下来的输入将被阻断，要用 `cin.clear()` 的命令来恢复输入。

另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则 `getline()` 和 `get()` 将把余下的字符留在输入队列中，`getline()` 还会设置失效位，并关闭后面的输入。

### 4.2.5 混合输入字符串和数字

![image-20210722012337405](https://static.fungenomics.com/images/2021/07/image-20210722012337405.png)

清单程序4.6 的一个问题是：
当cin读取年份，将回 车键生成的换行符留在了输入队列中。后面的cin.getline( )看到换行符 后，将认为是一个空行，并将一个空字符串赋给address数组。解决之道 是，在读取地址之前先读取并丢弃换行符。这可以通过几种方法来完 成，其中包括使用没有参数的get( )和使用接受一个char参数的get( )。

也可以利用表达式cin>>year返回cin对象，将调用拼接起来：

```Cpp
(cin >> year).get();  // or (cin >> year).get(ch);
```

## 4.3 string 类简介

`string` 类包含于头文件 `string` 并位于名称空间 `std` 中，使用起来比字符数组简单，它提供了将字符串作为一种数据类型的表示方法，符合 C++ 的风格。
string 类定义隐藏了字符串的数组性质，让我们能够像处理普通变量那样处理字符串。

在很多方面，使用 string 对象的方式和使用字符数组相同：

- 可以使用 C-风格字符串来初始化 string 对象；
- 可以使用 cin 来将键盘输入存储到 string 对象中；
- 可以使用 cout 来显示 string 对象；
- 可以使用数组表示法来访问存储在 string 对象中的字符。

string 对象和字符数组的主要区别是，可以将 string 对象声明为简单变量，而不是数组。

类设计让程序能够自动处理string的大小。例如，str1的声明创建一 个长度为0的 string 对象，但程序将输入读取到str1中时，将自动调整 str1 的长度。

这使得与使用数组相比，使用string对象更方便，也更安全。从理论上说，可以将char 数组视为一组用于存储一个字符串的 char 存储单元，而 string 类变量是一个表示字符串的实体。

###  4.3.1 C++11字符串初始化

![image-20210722141823630](https://static.fungenomics.com/images/2021/07/image-20210722141823630.png)

### 4.3.2 string 赋值、拼接和附加

string 可以如简单变量那般操作。比如，虽然不能将一个数组赋给另一个数组，但却可以将一个 string 对象赋给另一个 string 对象。

![image-20210722142110617](https://static.fungenomics.com/images/2021/07/image-20210722142110617.png)

可以使用运算符 + 将两个string 对象合并起来，还可以使用运算符 += 将字符串附加到string对象的末尾。

```Cpp
string str1 = "aa";
string str2 = "bb";
string str3;

str3 = str1 + str2;  // 正确
str3 += str1;        // 正确
str3 += " cc";       // 一样正确
```

### 4.3.3 string类的其他操作

处理string对象的语法通常比使用C字符串函数简单，尤其是执行较为复杂的操作时。例如，对于下述操作：

`str3 = str1 + str2;`

使用C-风格字符串时，需要使用的函数如下：

```Cpp
strcpy(charr3, charr1);
strcat(charr3, charr2);
```

`strcpy()` 和  `strcat()` 函数包含在头文件 cstring 中。函数 `strcpy()` 将字符串复制到字符数组中，使用函数 `strcat()` 将字符串附加到字符数组末尾。
另外，使用字符数组时，**总是存在目标数组过小，无法存储指定信息的危险**。

![image-20210722143658095](https://static.fungenomics.com/images/2021/07/image-20210722143658095.png)

函数strcat( )试图将全部12个字符复制到数组site中，这将覆盖相邻的内存。这可能导致程序终止，或者程序继续运行，但数据被损坏。** string类具有自动调整大小的功能，从而能够避免这种问题发生**。

### 4.3.4 string类I/O

![image-20210722144341278](https://static.fungenomics.com/images/2021/07/image-20210722144341278.png)

在用户输入之前，该程序指出数组charr中的字符串长度为27，这比 该数组的长度要大。这里要两点需要说明。首先，为初始化的数组的内 容是未定义的；其次，函数strlen( )从数组的第一个元素开始计算字节 数，直到遇到空字符。在这个例子中，在数组末尾的几个字节后才遇到 空字符。对于未被初始化的数据，第一个空字符的出现位置是随机的， 因此您在运行该程序时，得到的数组长度很可能与此不同。

用户输入之前，str中的字符串长度为0。这是因为未被初始化的string对象的长度被自动设置为0。 **这是和字符串数组不同的地方**。

源代码中是将一行输入读取到string对象中的代码是：`getline(cin, str);`。这个 `getline()` 不是类方法，它将 cin 作为参数，指出去哪里查找输入，另外，也没有指出字符串长度 的参数，因为 `string` 对象将根据字符串的长度自动调整自己的大小。

### 4.3.5 其他形式的字符串字面值

除char类型外，C++还有类型wchar_t；而C++11新 增了类型char16_t和char32_t。可创建这些类型的数组和这些类型的字符 串字面值。对于这些类型的字符串字面值，C++分别使用前缀L、u和U 表示，下面是一个如何使用这些前缀的例子：

![image-20210722162656588](https://static.fungenomics.com/images/2021/07/image-20210722162656588.png)

C++11还支持Unicode字符编码方案UTF-8。
C++11新增的另一种类型是原始（raw）字符串，并使用前缀 R 来标识，原始字符表示的就是自己，例如，序列 `\n` 不表示换行符，而表示两个常 规字符—斜杠和n，因此在屏幕上显示时，将显示这两个字符。

## 4.4 结构体简介

**结构体（Struct）**是 一种比数组更灵活的数据格式，因为同一个结构体可以存储多种不同类型的数据，从而将数据的表示合并到一起。

> 原文称 struct 为 “结构”，我认为这不符合一贯以来的称呼，因此在这个笔记中我一律改为通常在 `C/C++` 中所称呼的 “结构体”。

结构体是用户定义的类型，而结构体声明定义了这种类型的数据属性。结构体的定义需要用 关键字 **struct** 做标识。 定义了类型后，便可以创建这种类型的变量。以下例子是一个结构体的定义，它使用了一个适合用于存储字符串的 char数组、一个float和一个double。列表中的每一项都被称为结构体成员，因此 infatable 结构体有3个成员（参见图4.6）

![image-20210722163912443](https://static.fungenomics.com/images/2021/07/image-20210722163912443.png)

定义之后就可以将这个结构体当做常规的 C++ 数据类型（如同 int、double、string等）来使用。

在结构体类型中，可以通过使用成员运算符 `.` 来访问各个成员。

### 4.4.1 在程序中使用结构体

结构声明的位置很重要。

![image-20210722165020076](https://static.fungenomics.com/images/2021/07/image-20210722165020076.png)

结构体的初始化方式和数组一样，使用逗号分隔值列表，并将这些值用花括号括起。如:

![image-20210722165157045](https://static.fungenomics.com/images/2021/07/image-20210722165157045.png)

花括号中每个值可以独占一行，也可以将他们都放在同一行中，注意变量之间有逗号隔开就行，其他的随意。

### 4.4.2 C++11 结构体初始化

![image-20210722165537179](https://static.fungenomics.com/images/2021/07/image-20210722165537179.png)

### 4.4.3 结构体可以将string类作为成员吗?

可以，只要编译器支持 string 类型就没问题，唯一要注意的问题注意添加名字空间 std 。 如:

![image-20210722165802188](https://static.fungenomics.com/images/2021/07/image-20210722165802188.png)

### 4.4.4 其他结构属性

结构体和 C++ 内置类型的用法类似，它可以作为参数传递给函数，也可以让函数返回一个结构体。另外，**还可以使用赋值运算符（=）将结构体赋给另一个同类型的结构体**，这样结构体中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值（memberwise assignment）。

结构体类型还可以同时完成定义结构体和创建结构体变量的工作，只需将变量名放在结束括号的后面即可：

![image-20210722170446818](https://static.fungenomics.com/images/2021/07/image-20210722170446818.png)

但不推荐这样做，将结构体定义和变量声明分开，可以使程序更易于阅读和理解。

### 4.4.5 结构体数组

创建结构体数组的方法和创建 C++ 基本类型的数组完全相同。

要初始化结构体数组，可以使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构体的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。由于数组中的每个 元素都是结构，因此可以使用结构初始化的方式来提供它的值。

![image-20210722170912740](https://static.fungenomics.com/images/2021/07/image-20210722170912740.png)

## 4.5 共用体

共用体（union），也叫联合体是一种数据格式，它能够存储不同的数据类型， 但只能同时存储其中的一种类型。也就是说，结构体可以同时存储 int、 long和double，共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。如：

![image-20210722171406230](https://static.fungenomics.com/images/2021/07/image-20210722171406230.png)

**共用体每次只能存储一个值**，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的。

共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省内存空间，其实对当前内存充裕的计算机来说，并非很有必要使用共用体。

## 4.6 枚举

这也是一个很少用的类型，略。
![image-20210722171825483](https://static.fungenomics.com/images/2021/07/image-20210722171825483.png)

## 4.7 指针和自由存储空间

计算机在存储数据时必须跟踪的3种基本属性：

- 信息存储在何处；
- 存储的值为多少；
- 存储的信息是什么类型。

C++ 提供了一种策略，可以在程序内部跟踪内存单元，这个策略以指针为基础。C++ 中 **指针是一个变量，其存储的是值的地址，而不是值本身**。

首先，我们如何找到常规变量的地址？在C/C++中只需对变量应用地址运算符 `&`，就可以获得它的位置；例如，如果 `home` 是一个变量，则 `&home` 是它在内存中的地址。

**使用常规变量时，值是指定的量，而地址为派生量**。接下来看看指针策略，它是C++内存管理编程理念的核心。

![image-20210722232030057](https://static.fungenomics.com/images/2021/07/image-20210722232030057.png)

指针处理存储数据的新策略刚好相反，**指针将地址视为指定的量，而将值视为派生量**，因此，指针名表示的是地址。`*` 运算符被称为**间接值（indirect velue）或解除引用 （dereferencing）运算符**，应用于指针得到该地址处所存储的值。例如，假设 `manly` 是一个指针，则 `manly` 表示的是一个地址，`*manly` 表示存储在该地址处的值，即 `*manly` 和常规变量等效。**变量的指针和变量的值本身本质只不过是一个硬币的两个面**。

> 变量是编译时分配出来的一个有名称的内存，这是变量的实质。而指针是一个可以通过名称直接访问内存的别名，内存里存储的东西就是变量的值。

![image-20210722233255845](https://static.fungenomics.com/images/2021/07/image-20210722233255845.png)

### 4.7.1 声明和初始化指针

不同数据类型存储值时的内存格式不同，所以指针声明时必须 **指定指针指向的数据类型**，声明一个指针的通用方式:

```
typeName *p_name;
```

`*` 符用于指明该变量是指针，每个指针变量声明时都需要带 `*`。

![image-20210722233705755](https://static.fungenomics.com/images/2021/07/image-20210722233705755.png)

使用指针的时候要注意区分地址是地址，值是值。指针本身也是一种数据类型，它的值是地址，这个地址也有它自己的字节长度（由计算机系统内定），它的长度和它这个地址里存储的数值没有任何关系。指向 int 类型和指向 double 类型或者 string 类型的指针类型的字节长度都是一样的，它们都是地址。

### 4.7.2 指针的危险

**创建指针时，计算机将分配用来存储指针这个变量本身的内存，但不会分配指针所指向的数据所需的内存**。为数据提供空间是一个独立的步骤，如果忽略这一步麻烦就大了。如：

```Cpp
long *fellow;       // 创建一个指向 long 类型的指针
*fellow = 223323;   // 指针还不知道指向哪个地址，就强制赋值，大错特错
```
声明时，只是告诉程序 `fellow` 是一个 `long` 指针，程序只给 `fellow` 这个指针变量分配了一个属于 `fellow` 自己的存储空间，至于它里面要存什么地址值还完全不知道。必须先申请一个存 `long` 类型的地址空间，然后赋值给 `fellow`，最后才可以将 223323 赋值过去。 

> 一定要在对指针应用解除引用运算符 `*` 之前，将指针初始化为一个确定的、适当的地址，这是关于使用指针的铁律。

### 4.7.3 指针和数字

指针不是整型，虽然计算机通常把地址当作整数来处理。在有些平台 中，int 类型是个2字节值，而地址是个4字节值。

### 4.7.4 使用new来分配内存

指针真正的用武之地在于，运行阶段分配未命名的内存用于存储值。C++ 通过 new 运算符为变量分配内存。

程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长 度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋 给一个指针。下面是一个这样的示例：

```Cpp
int *pn = new int;
```
`new int` 告诉程序，需要适合存储 `int` 的内存。`new` 运算符根据类型来确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。 接下来，将地址赋给 `pn`，`pn` 是被声明为指向 `int` 的指针。现在，`pn` 是地址，而 `*pn` 是存储在那里的值。

**注意：`pn` 指向的内存不是变量（那是一个地址，是不变的），内存里存储的东西才是可变的。**

> 这引出了一个问题：pn指向的内存没 有名称，如何称呼它呢？我们说pn指向一个数据对象，这里的“对象”不 是“面向对象编程”中的对象，而是一样“东西”。术语“数据对象”比“变 量”更通用，它指的是为数据项分配的内存块。

为一个数据对象（可以是结构，也可以是基本类型）获得并指定分 配内存的通用格式如下：

```Cpp
typeName *pointer_name = new typeName;
```

需要指出的另一点是，`new` 分配的内存块通常与常规变量声明分配的内存块不同。常规变量存储在被称为栈 （stack）的内存区域中，而 `new` 从被称为堆（heap）或自由存储区（free store）的内存区域分配内存。

如果内存分配失败，`new` 运算符将返回空指针（null pointer），其值为 0。

### 4.7.5 使用 delete 释放内存

**`delete` 运算符，用于将不再使用的内存归还给内存池**，归还或释放（free）的内存可供程序的其他部分使用。使用 `delete` 时，后面要加上指向内存块的指针（这些内存块最初是用new分配的）。

```Cpp
int *ps = new int;   // 声明指针并分配一个可以存 int 类型的内存给指针
...
delete ps;  // 归还内存
```

归还 ps 指向的内存，并不会删除指针 ps 本身，它可以继续用来指向新分配的内存。

** `new` 和 `delete` 一定要配对使用，否则会导致程序发生内存泄露（memory leak）**，即分配出去的内存拿不回来，无法再使用。

![image-20210723144325225](https://static.fungenomics.com/images/2021/07/image-20210723144325225.png)



另外，不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。

> 一般来说，不要创建两个指向同一个内存块的指针，因为这将增加 错误地删除同一个内存块两次的可能性。

另外，不能使用 `delete` 释放声明变量所获得的内存，**只能用它释放 `new` 分配的内存**，这是关键点。

![image-20210723105004298](https://static.fungenomics.com/images/2021/07/image-20210723105004298.png)

### 4.7.6 使用new来创建动态数组

对于大型数据（如数组、字符串和结 构），应使用new，这正是new的用武之地。

在编译时给数组分配内存被称为静态联编（static binding），这就是为什么只能分配固定大小的数组。但使用 `new` 时，在运行阶段需要数组，则创建它；如果不需 要，则不创建，还可以选择数组的长度，这被称为动态联 编（dynamic binding），意味着数组是在程序运行时创建的。

1．使用 new 创建动态数组

创建动态数组很容易；只要将数组的元素类型和元素数 目告诉new即可。必须在类型名后加上方括号，其中包含元素数目。为数组分配内存的通用格式如下：

```
typeName *pointer_name = new typeName [num_elements];
```

给个例子如：

```Cpp
int *psome = new int [10];  // 分配可以存储 10 个 int 的内存块
```

`new` 返回第一个元素的地址，并将该地址被赋给指针 `psome`。

释放这一块内存时要这样做：
```Cpp
delete [] psome;
```
方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。 **注意delete和指针之间有方括号**。对于 ANSI/ISO标准来说，`new` 与 `delete` 的格式要匹配，否则导致的后果是不确定。

总之，使用new和delete时，应遵守以下规则：

- 不要使用 `delete` 来释放不是 `new` 分配的内存；
- 不要使用 `delete` 释放同一个内存块两次；
- 如果使用 `new []` 为数组分配内存，则应使用 `delete []` 来释放；
- 如果使用 `new []` 为一个实体分配内存，则应使用 `delete`（没有方括 号）来释放(这一点要找例子来理解)；
- 对空指针应用 `delete` 是安全的。

2．使用动态数组

创建动态数组后，如何使用它呢？**只需要将指针名当做数组名，然后按照数组的访问方式即可**，C/C++ 中数组和指针是基本等价的（但也有实质区别，后续再说）。例子：

```Cpp
int *psome = new int [10];
```

对于第1个元素，可以使用 `psome[0]`，而不是 `*psome`；对于第2个元 素，可以使用 `psome[1]`，依此类推。

程序清单4.18演示了如何使用new来创建动 态数组以及使用数组表示法来访问元素；它还指出了指针和真正的数组名之间的根本差别（注意红框）。

![image-20210723111823885](https://static.fungenomics.com/images/2021/07/image-20210723111823885.png)

将`p3` 加1导致它指向第2个元素而不是第1个。将它减1后，指针将指向原来的值，这样程序便可以给 `delete[]` 提供正确的地址。(这叫指针移动)

## 4.8 指针、数组和指针算术

指针算术是有特殊之处的。

**指针和数组基本等价的原因在于指针算术（pointer arithmetic）和 C++ 内部处理数组的方式**。

> 将整数变量加1 后，其值将增加1；但将指针变量加1后，增加的量等于它指向的类型的 字节数。将指向double的指针加1后，如果系统对double使用8个字节存 储，则数值将增加8；将指向short的指针加1后，如果系统对short使用2 个字节存储，则指针值将增加2。

### 4.8.1 程序说明

![image-20210723112411334](https://static.fungenomics.com/images/2021/07/image-20210723112411334.png)

**将指针变量加1后，其增加的值等于指向的类型占用的字节数**。 也就是跳到下一个存储值的地址上。

从该程序的输出可知，`*（stacks + 1）`和 `stacks[1]` 是等价的。同样， `*（stacks + 2）`和 `stacks[2]` 也是等价的。通常，使用数组表示法时，`C++` 都执行下面的转换：

```
arrayname[i] becomes *(arrayname + i)
```

如果使用的是指针，而不是数组名，则C++也将执行同样的转换：

```
pointername[i] becomes *(pointername + i)
```
因此，在很多情况下，可以相同的方式使用指针名和数组名。也就是说，使用 `new` 来创建数组以及使用指针来访问不同的元素时，只要把指针当作数组名对待即可。

**【注意】数组名被解释为其第一个元素的地址，而对数组名应用地址运算符 时，得到的是整个数组的地址，区别很大。**



![image-20210723113548998](https://static.fungenomics.com/images/2021/07/image-20210723113548998.png)

### 4.8.2 指针小结

1．声明指针
要声明指向特定类型的指针，请使用下面的格式：
```Cpp
typeName *pointer_name;
```
2．给指针赋值

应将内存地址赋给指针。可以对变量名应用 `&` 地址运算符，来获得被命名的内存的地址，或 `new` 运算符返回未命名的内存的地址。

3．对指针解引用

对指针解引用意味着获得指针指向的值。`*` 是指针应用解引用或间接值运算符。

4．区分指针和指针所指向的值

如果 `pt` 是指向int的指针，则 `*pt` 不是指向 `int` 的指针，而是完全等同于 一个 `int` 类型的变量，`pt` 才是指针。

5．数组名

大多数情况下，C++将数组名视为数组的第一个元素的地址。一种例外情况是，将sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）。

6．指针算术

C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数，也就是移动到下一个存储值的地址。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数 组（也可以指向超出结尾的一个位置）时，这种运算才有意义，这将得到两个元素的间隔。

7．数组的动态联编和静态联编

使用数组声明来创建数组时，将采用静态联编，即数组的长度在编 译时设置。
使用 `new[]` 运算符创建数组时，将采用动态联编（动态数组），即将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应使用 `delete []` 释放其占用的内存。

8．数组表示法和指针表示法

使用方括号数组表示法等同于对指针解引用。数组名和指针变量都是如此，因此对于指针和数组名，既可以使用 指针表示法，也可以使用数组表示法。

![image-20210723115130804](https://static.fungenomics.com/images/2021/07/image-20210723115130804.png)

### 4.8.3 指针和字符串

数组和指针的特殊关系可以扩展到C-风格字符串。

```Cpp
char flower[10] = "rose";
cout << flower << "s are red.\n";
```

以上代码中，数组名是第一个元素的地址，因此cout语句中的flower是包含字符r 的char元素的地址。cout对象认为char的地址是字符串的地址，因此它打 印该地址处的字符，然后继续打印后面的字符，直到遇到空字符 (\0)  为止。总之，如果给cout提供一个字符的地址，则它将从该字符开始打 印，直到遇到空字符为止。

**这意味着可以将指向char的指针变量作为cout的参数，因为它也是 char的地址。**
在C++中，用引号括起的字符串像数组名一样，也是第一个元素的地 址。这意味着对于数组中的字符串、用引号括起的字符串常量以及指针 所描述的字符串，处理的方式是一样的，都将传递它们的地址。与逐个 传递字符串中的所有字符相比，这样做的工作量确实要少。

> 在 cout 和多数 C++ 表达式中，`char` 数组名、`char` 指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址。

请不要使用字符串常量或未被初始化的指针来接收输入。为避免这 些问题，也可以使用std::string对象，而不是数组。

在将字符串读入程序时，应使用已分配的内存地址。该地址可以是数组名，也可以是使用new 初始化过的指针。

注意这段代码及其输出：

![image-20210723122618520](https://static.fungenomics.com/images/2021/07/image-20210723122618520.png)

一般来说，如果给cout提供一个指针，它将打印地址。但如果指针 的类型为 `char *`，则 cout将显示指向的字符串。如果要显示的是字符串的 地址，则必须将这种指针强制转换为另一种指针类型，如 `int *`（上面的 代码就是这样做的）。

经常需要将字符串放到数组中。初始化数组时，请使用=运算符； 否则应使用strcpy( )或strncpy( )。应使用strcpy( )或strncpy( )，而不是赋值运算符来将字符串赋给数组。

> 这是 C-风格 字符串的操作方式，C++ string 类型则并不需要如此，会简单得多，不用担心字符串会导致数 组越界，并可以使用赋值运算符而不是函数strcpy( )和strncpy( )。

### 4.8.4 使用 new 创建动态结构体

在运行时创建数组优于在编译时创建数组，对于结构也是如此。通过使用new，可以创建动态结构。

将 new 用于结构体由两步组成：创建结构体和访问其成员。要创建结构体，需要同时使用结构体类型和 new。

```Cpp
inflatable *ps = new inflatable;
```
这将把足以存储inflatable结构的一块可用内存的地址赋给ps。这种 句法和C++的内置类型完全相同。

此时要访问结构体成员，需通过箭头成员运算符 `−>`，它用于指向结构体的指针，就像点运算符可用于结构体名一样，如 `ps->price` 指向了结构体中的 price 成员。

![image-20210723134422484](https://static.fungenomics.com/images/2021/07/image-20210723134422484.png)

> 如果结构标识符是结构名，则使用句点运算符；如果标识符是指向结构 的指针，则使用箭头运算符。

另一种访问结构成员的方法是先对指针解引用。如果 `ps` 是指向结构的指针，则 `*ps` 就是被指向的值—结构本身。由于 `*ps` 是一个结构，因此 `(*ps).price` 是 该结构的 `price` 成员。

![image-20210723134903499](https://static.fungenomics.com/images/2021/07/image-20210723134903499.png)

### 4.8.5 自动存储、静态存储和动态存储

根据用于分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存在时间的长短方面，以这3种方式分配的数据对象各不相同。

1. 自动存储

在函数内部定义的常规变量使用自动存储空间，被称为自动变量 （automatic variable），只在包含它的代码中有效，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。

自动变量通常存储在栈中。

2. 静态存储

静态存储是整个程序执行期间都存在的存储方式。使变量成为静态 的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用 关键字 `static`。

3. 动态存储

`new` 和 `delete` 运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的。

## 4.9 类型组合

指针数组，指向指针的指针，也叫二维指针可以用来创建动态二维数组，类型较为复杂。

![image-20210723150508488](https://static.fungenomics.com/images/2021/07/image-20210723150508488.png)

## 4.10 数组的替代品

STL 标准库中的模板类 `vector` 和 `array` 是数组的替代品。

### 4.10.1 模板类 vector

模板类 `vector` 类似于 `string` 类，也是一种动态数组，创建时要包含头文件 vector 。可以在运行阶段设置 `vector` 对象的长度，也可在末尾附加新数据，还可以在中间插入新数据，`vector` 的长度不要求必须设定，因为它会依据插入的数据量自动增长，容量增长的速度是 2 的 `n` 次方。

基本上，它是使用 `new` 创建动态数组的替代品。实际上，`vector` 类确实使用 `new` 和`delete` 来管理内存，但这种工作是自动完成的。

`vector` 的声明方式：

```Cpp
#include<vector>
vector<typeName> v_name(number);
```

这样 v_name 就是一个 vector 对象，但 number 不是必须的。

`vector` 的最完整文档和例子，应参照网站 <http://cplusplus.com/reference/vector/vector> 。 

### 4.10.2 模板类array（C++11）

`vector` 类的功能比数组强大，但付出的代价是效率稍低（其实没那么低效）。如果您需 要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便 和安全。有鉴于此，C++11 新增了模板类 `array`，它也位于名称空间 `std` 中。与数组一样，`array` 对象的长度也是固定的，也使用栈（静态内存分 配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。

要创建array对象，需要包含头文件array。array对象的创建语法与 vector稍有不同：

```Cpp
#include<array>

array<typeName, num_element> arr;
```

与创建 `vector` 对象不同的是，n_element 不能是变量，必须是固定的常量和普通数组要求一样。

> 通过 `array` 模板类创建数组有什么优势？

<https://cplusplus.com/reference/array/array>

### 4.10.3 比较数组、vector 对象和 array 对象

这三者的异同是什么？

首先，无论是数组、`vector` 对象还是 `array` 对象，都可使用标 准数组表示法来访问各个元素；

其次，从地址可知，`array` 对象和数组存 储在相同的内存区域（即栈）中，而`vector` 对象存储在另一个区域（自由存储区或堆）中；

第三，**可以将一个 `array` 对象直接赋给另一个 `array` 对象，而标准数组，必须逐元素复制数据** (使用 array 模板类的两个好处之一，另一个好处是控制数组超界风险)。

例子：

![image-20210723153517389](https://static.fungenomics.com/images/2021/07/image-20210723153517389.png)

![image-20210723160219245](https://static.fungenomics.com/images/2021/07/image-20210723160219245.png)

在上面代码中注意一个语句：

```Cpp
a1[-2] = 20.2;
```

这是什么意思？这个语句会被转换为：
```Cpp
*(a1 - 2) = 20.2;
```

含义是：找到a1指向的地方，向前移两个double元素，并将 20.2存储到目的地。也就是说，将信息存储到数组的外面。**与C语言一 样，C++也不检查这种超界错误**，也就是说数组的这种行为是不安全的，C++ 却不禁止，要小心。

`vector` 和 `array` 对象能够禁止这种行为吗？如果您让它们禁止，它们 就能禁止。另外，这 些类还让您能够降低意外超界错误的概率。例如，它们包含成员函数 `begin()` 和 `end()`，让您能够确定边界，以免无意间超界。


## 4.11 总结

数组、结构体和指针是C++的3种复合类型。

数组可以在一个数据对 象中存储多个同种类型的值。通过使用索引或下标，可以访问数组中各 个元素。

结构体可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符`.` 来访问其中的成员。使用结构体的第一步是创建结构体模板，它定义结构存储了哪些成员。**模板的名称将成为新类型的标识符，然后就可以声明这种类型的结构变量**。

指针是被设计用来存储地址的变量，指针指向它存储的地 址。指针声明指出了指针指向的对象的类型。对指针应用解引用运算符 `*`，将得到指针指向的位置中的值。

字符串是以空字符为结尾的一系列字符。字符串可用引号括起的字 符串常量表示，其中隐式包含了结尾的空字符。可以将字符串存储在 char数组中，可以用被初始化为指向字符串的char指针表示字符串。

`string` 对象将根据要存储的字符串自动调整其 大小，用户可以使用赋值运算符来复制字符串。

`new` 运算符允许在程序运行时为数据对象请求内存。该运算符返回 获得内存的地址，可以将这个地址赋给一个指针，程序将只能使用该指 针来访问这块内存。使用解引用运算符 `*` 获得其值；如果数据对象是数组，则可以像使用数组名那样使用指针来访问元素；如果数据对象是结构体，则可以用指针解引用运算符 `->` 访问其成员。

指针和数组紧密相关。如果 `ar` 是数组名，则表达式 `ar[i]` 被解释为  `*(ar + i)`（ `i` 可以是负值，表示指针左移），其中数组名被解释为数组第一个元素的地址。这样，数组名的作用和指针相同。反过来，可以使用数组表示法，通过指针名来访 问new分配的数组中的元素。

运算符 `new` 和 `delete` 允许显式控制何时给数据对象分配内存，何时将内存归还给内存池。


# 第五章 循环和关系表达式

本章内容包括：

- for 循环；
- 表达式和语句；
- 递增运算符和递减运算符： ++ 和 --；
- 组合赋值运算符；
- 复合语句（语句块）；
- 逗号运算符；
- 关系运算符：>、>=、==、<=、< 和 !=；
- while 循环；
- typedef 工具；
- do while 循环；
- 字符输入方法 get() ；
- 文件尾条件；
- 嵌套循环和二维数组。

## 5.1 for 循环

### 5.1.1 for 循环初始化

for循环为执行重复的操作提供了循序渐进的步骤。组成部分完成下面这些步骤：

- 设置初始值；
- 执行测试，判断循环是否应当继续进行；
- 执行循环操作；
- 更新用于测试的值。

初始化、测试和更 新操作构成了控制部分，这些操作由括号括起。其中每部分都是一个表 达式，彼此由分号隔开。控制部分后面的语句叫作循环体，只要测试表 达式为true，它便被执行：

```Cpp
for (initialization; test-expression; update-expression)
	body;
```

循环体如果大于一条语句，需要加花括号：

```Cpp
for (initialization; test-expression; update-expression) {
	body;
}
```

C++语法将整个for看作一条语句—虽然循环体可以包含一条或多条 语句。循环只执行一次初始化。

`for` 是一个 C++ 关键字，编译器不会将 `for` 视为一个函 数，这还将防止将函数命名为 `for`。

![image-20210727003613922](https://static.fungenomics.com/images/2021/07/image-20210727003613922.png)

> 【编程风格 Tips】C++ 常用的方式是，在 for 和括号之间加上一个空格，但省略函数名与括号之间的空格。

看这个表达式赋值逻辑：

```Cpp
x = y = z = 0;
```

**赋值运算符是从右向左结合的**，因此首先将0赋给z，然 后将z = 0赋给y，依此类推。

C++在C循环的基础上添加了一项特性，要求对for循环句法做一些 微妙的调整。

这是原来的句法：

```Cpp
for (expresson; expression; expression)
	statement;
```

但，C++循环允许像下面这样做：

```Cpp
for (int i=0; i<5; ++i)
```

也就是说，可以在for循环的初始化部分中声明变量。这很方便，但并不适用于原来的句法，因为声明不是表达式。这个变量的生存时间只存在于for语句中，也就是说，当程序离开循环后，`i` 这个变量将消失。

### 5.1.2 回到for循环
很简单，略。

### 5.1.3 修改步长

循环示例每一轮循环都将循环计数加1或减1。可以通 过修改更新表达式来修改步长，例如改为表达式 `i = i + by`，其中 `by` 是用户选择的步长值。

### 5.1.4 使用for循环访问字符串

很简单，略。

### 5.1.5 递增运算符（++）和递减运算符（−−）

这两个运算符执行两种极其常见 的循环操作：将循环计数加1或减1。这两个运算符都有两种变体。前缀（prefix）版本位于操作数前 面，如++x；后缀（postfix）版本位于操作数后面，如x++。两个版本对操作数的影响是一样的，但是影响的时间不同。这就像对于钱包来说， 清理草坪之前付钱和清理草坪之后付钱的最终结果是一样的，但支付钱 的时间不同。

**粗略地讲，a++意味着使用a的当前值计算表达式，然后将a的值加 1；而++b的意思是先将b的值加1，然后使用新的值来计算表达式。** 递减操作符也同理。

![image-20210727010134791](https://static.fungenomics.com/images/2021/07/image-20210727010134791.png)

### 5.1.6 副作用和顺序点

C++就递增运算符何时生效的哪些方面做了规 定，哪些方面没有规定。首先，副作用（side effect）指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；顺序点 （sequence point）是程序执行过程中的一个点，在这里，进入下一步之 前将确保对所有的副作用都进行了评估。在C++中，**语句中的分号就是 一个顺序点**，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。

另外，任何完整的表达式末尾都是一个顺序点。

何为完整表达式呢？它是这样一个表达式：不是另一个更大表达式 的子表达式。完整表达式的例子有：表达式语句中的表达式部分以及用 作while循环中检测条件的表达式。

![image-20210727010733540](https://static.fungenomics.com/images/2021/07/image-20210727010733540.png)

### 5.1.7 前缀格式和后缀格式

如果变量被用于某些目的（如用作函数参数或给变量赋 值），使用前缀格式和后缀格式的结果将不同。

然而，虽然选择使用前缀格式还是后缀格式对程序的行为没有影 响，但执行速度可能有细微的差别。对于内置类型和当代的编译器而 言，这看似不是什么问题。然而，C++允许您针对类定义这些运算符， 在这种情况下，用户这样定义前缀函数：将值加1，然后返回结果；但后缀版本首先复制一个副本，将其加1，然后将复制的副本返回。因 此，对于类而言，前缀版本的效率比后缀版本高。

### 5.1.8 递增/递减运算符和指针

可以将递增运算符用于指针和基本变量。将递增 运算符用于指针时，将把指针的值增加其指向的数据类型占用的字节数，这种规则适用于对指针递增和递减。

前缀递增、前缀递减和解引用运算符的优先级相同，以从右到左的方式进行结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。

前缀运算符的从右到到结合规则意味着 `*++pt` 的含义如下：现将 `++` 应用于 `pt`（因为 `++` 位于 `*` 的右边），然后将 `*` 应用于被递增后的 `pt`。 另一方面，`++*pt` 意味着先取得 `pt` 指向的值，然后将这个值加 1，`pt` 依然指向原来的地址；

而这个组合 `(*pt)++` 圆括号指出，首先对指针解引用，得到值。然后，运算符++将这个值递增 1，但 `pt` 仍然指在原来的地址。 

### 5.1.9 组合赋值运算符

`+=` 运算符将两个操作数相加，并将结果赋给左边的操作数。这意味着左边的操作数必须能够被赋值，如变量、数组元素、结构体成员或通过对指针解引用来标识的数据。

![image-20210727012040437](https://static.fungenomics.com/images/2021/07/image-20210727012040437.png)

![image-20210727012104165](https://static.fungenomics.com/images/2021/07/image-20210727012104165.png)

### 5.1.10 复合语句（语句块）

只有这个地方要注意：假设对循环体进行了缩进，但省略了花括号，编译器将忽略缩进，因此只有第一条语句位于循环中。

![image-20210727012230040](https://static.fungenomics.com/images/2021/07/image-20210727012230040.png)


### 5.1.11 其他语法技巧—逗号运算符

语句块允许把两条或更多条语句放到按C++句法 只能放一条语句的地方。逗号运算符对表达式完成同样的任务，允许将 两个表达式放到C++句法只允许放一个表达式的地方。如：

```Cpp
++j, --i你  // 没有分号，合法，但不能独立运行，要在另外语句中，如 for 里
```

![image-20210727012641834](https://static.fungenomics.com/images/2021/07/image-20210727012641834.png)

但逗号并不总是逗号运算符。 如：

```Cpp
int i, j; // 个声明中的逗号将变量列 表中相邻的名称分开
```

到目前为止，逗号运算符最常见的用途是将两个或更多的表达式放 到一个for循环表达式中。不过C++还为这个运算符提供了另外两个特 性。首先，它确保先计算第一个表达式，然后计算第二个表达式（换句 话说，逗号运算符是一个顺序点）。

```Cpp
i = 20, j = 2 * i   // 这是合法的，这里 y 是 40
```
在所有运算符中，逗号运算符的优先级是最低的。

![image-20210727013030988](https://static.fungenomics.com/images/2021/07/image-20210727013030988.png)

### 5.1.12 关系表达式

![image-20210727013059937](https://static.fungenomics.com/images/2021/07/image-20210727013059937.png)

### 5.1.13 赋值、比较和可能犯的错误

很简单，略。

### 5.1.14 C-风格字符串的比较

假设要知道字符数组中的字符串是不是mate。如果word是数组名， 下面的测试可能并不能像我们预想的那样工作：

```Cpp
word == "mate"
```

请记住，数组名是数组的地址。同样，用引号括起的字符串常量也 是其地址。因此，上面的关系表达式不是判断两个字符串是否相同，而 是查看它们是否存储在相同的地址上。两个字符串的地址是否相同呢？ 回答是否定的，虽然它们包含相同的字符。

由于C++将C-风格字符串视为地址，因此如果使用关系运算符来比 较它们，将无法得到满意的结果。需要用 C 字符串库中的 strcmp() 函数来比较。 该函数接受两个字符串地址作为参数。这意味着 参数可以是指针、字符串常量或字符数组名。如果两个字符串相同，该 函数将返回零；如果第一个字符串按字母顺序排在第二个字符串之前， 则strcmp( )将返回一个负数值；如果第一个字符串按字母顺序排在第二 个字符串之后，则strcpm( )将返回一个正数值。实际上，“按系统排列顺 序”比“按字母顺序”更准确。这意味着字符是根据字符的系统编码来进 行比较的。例如，使用ASCII码时，所有大写字母的编码都比小写字母 小，所以按排列顺序，大写字母将位于小写字母之前。因此，字符 串“Zoo”在字符串“aviary”之前。

存储在不同长度的数组 中的字符串彼此不相等。但是C-风格字符串是通过结尾的空值字符定义 的，而不是由其所在数组的长度定义的。这意味着两个字符串即使被存 储在长度不同的数组中，也可能是相同的。

![image-20210727014019373](https://static.fungenomics.com/images/2021/07/image-20210727014019373.png)

### 5.1.15 比较string类字符串

如果使用string类字符串而不是C-风格字符串，比较起来将简单些。直接通过运算符比较：>, <, == 等。

## 5.2 while 循环

`while` 循环是一个没有初始化和更新部分的 `for` 循环，它只有测试条件和循环体，与for循环一样，循环体也由一条语句或两个花括号定义的语句块组成。句法如下：

```Cpp
while (test-condition)
    body
```

如果循环体有多条语句，需要花括号：

```Cpp
while (test-condition) {
    body
}
```

首先，程序计算圆括号内的测试条件（test-condition）表达式。如 果该表达式为true，则执行循环体中的语句。执行完循环体后，程序返 回测试条件，对它进行重新评估。如果该条件为非零，则再次执行循环 体。测试和执行将一直进行下去，直到测试条件为false为止。

while 循环和 for 循环一样，也是一 种入口条件循环。因此，如果测试条件一开始便为false，则程序将不会 执行循环体。

![image-20210727121115868](https://static.fungenomics.com/images/2021/07/image-20210727121115868.png)

### 5.2.1 for 与 while

在C++中，for 和 while 循环本质上是相同的。

![image-20210727121739245](https://static.fungenomics.com/images/2021/07/image-20210727121739245.png)

但它们之间存在三个差别：

- 在 `for` 循环中省略了测试条件时，将认为条件为 `true`；
- 在 `for` 循环中，可使用初始化语句声明一个局部变量，但在 `while` 循环中不能这样做；
- 如果循环体中包括 `continue` 语句，情况将稍有不同，`continue` 语句将在第6章讨论。

通常，程序员使用 `for` 循环来为循环计数，因为 `for` 循环格式允许将所有相关的信息—初始值、终止值和更新计数器的方法—放在同一个地方。在无法预先知道循环将执行的次数时，程序员常使用 `while` 循环。


### 5.2.2 等待一段时间：编写延时循环

函数 `clock()` 可以返回程序开始执行后所用的系统时间。但，首先，clock( )返回时间的单位不一定是秒；其次，该函数的返回类 型在某些系统上可能是long，在另一些系统上可能是unsigned long或其 他类型。

头文件 `ctime` 提供了这些问题的解决方案。首先，它定义了一个符号常量—`CLOCKS_PER_SEC`，该常量等于 每秒钟包含的系统时间单位数。因此，将系统时间除以这个值，可以得 到秒数。或者将秒数乘以 `CLOCK_PER_SEC`，可以得到以系统时间单位 为单位的时间。其次，`ctime` 将 `clock_t` 作为 `clock()` 返回类型的别名，这意味着可以将变量声明为 `clock_t` 类型，编译器将把它转换为long、unsigned int 或适合系统的其他类型。

![image-20210727133448815](https://static.fungenomics.com/images/2021/07/image-20210727133448815.png)

## do while 循环

它 不同于另外两种循环，因为它是出口条件（exit condition）循环。这意 味着这种循环将首先执行循环体，然后再判定测试表达式，决定是否应 继续执行循环。如果条件为false，则循环终止；否则，进入新一轮的执 行和测试。这样的循环通常至少执行一次，循环体是一条语句或用括号括起的语句块。句法：

```Cpp
do {
	body
} while (test-condition);
```

![image-20210727135803904](https://static.fungenomics.com/images/2021/07/image-20210727135803904.png)

## 5.4 基于范围的for循环（C++11）

C++11新增了一种循环：基于范围（range-based）的for循环。这简化了一种常见的循环任务：对数组（或容器类，如vector和array）的每 个元素执行相同的操作。


## 5.5 循环和文本输入

### 5.5.1 使用原始的cin进行输入

为什么程序在输出时省略了空格呢？原因 在cin。读取char值时，与读取其他基本类型一样，cin将忽略空格和换行 符。因此输入中的空格没有被回显，也没有被包括在计数内。

更为复杂的是，发送给cin的输入被缓冲。这意味着只有在用户按 下回车键后，他输入的内容才会被发送给程序。这就是在运行该程序 时，可以在#后面输入字符的原因。按下回车键后，整个字符序列将被 发送给程序，但程序在遇到#字符后将结束对输入的处理。

### 5.5.2 使用cin.get(char)进行补救

通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制 表符和换行符。`cin` 所属的 `istream` 类（在 `iostream` 中定义）中包含一个能 够满足这种要求的成员函数。具体地说，成员函数cin.get(ch)读取输入 中的下一个字符（即使它是空格），并将其赋给变量ch。使用这个函数 调用替换cin>>ch，可以修补程序清单5.16的问题。

![image-20210727161504704](https://static.fungenomics.com/images/2021/07/image-20210727161504704.png)

> 在C语言中， 要修改变量的值，必须将变量的地址传递给函数。但程序清单5.17调用 cin.get( )时，传递的是ch，而不是&ch。在C语言中，这样的代码无效， 但在C++中有效，只要函数将参数声明为引用即可。引用是C++在C语 言的基础上新增的一种类型。头文件iostream将cin.get(ch)的参数声明为 引用类型，因此该函数可以修改其参数的值。


### 5.5.3 使用哪一个cin.get( )

函数重载允许创建多个同名函数，条件是它们 的参数列表不同。例如，如果在C++中使用 `cin.get(name，ArSize)`， 则编译器将找到使用 `char*` 和 `int` 作为参数的 `cin.get()` 版本；如果使用 `cin.get(ch)`，则编译器将使用接受一个 `char` 参数的版本；如果没有提 供参数，则编译器将使用不接受任何参数的`cin.get()` 版本。函数重载允 许对多个相关的函数使用相同的名称，这些函数以不同方式或针对不同类型执行相同的基本任务。

### 5.5.4 文件尾条件

如果输入来自于文件，则可以使用一种功能更强大的技 术—检测文件尾（EOF）。C++输入工具和操作系统协同工作，来检测文件尾并将这种信息告知程序。

检测到EOF后，cin将两位（eofbit和failbit）都设置为1。可以通过 成员函数eof( )来查看eofbit是否被设置；如果检测到EOF，则cin.eof( )将 返回bool值true，否则返回false。同样，如果eofbit或failbit被设置为1， 则fail( )成员函数返回true，否则返回false。

![image-20210727162259773](https://static.fungenomics.com/images/2021/07/image-20210727162259773.png)


### 5.5.5 另一个cin.get( )版本

为成功地使用cin.get( )，需要知道其如何处理EOF条件。当该函数 到达EOF时，将没有可返回的字符。相反，cin.get( )将返回一个用符号 常量EOF表示的特殊值。该常量是在头文件iostream中定义的。EOF值 必须不同于任何有效的字符值，以便程序不会将EOF与常规字符混淆。 通常，EOF被定义为值−1，因为没有ASCII码为−1的字符，但并不需要知道实际的值，而只需在程序中使用EOF即可。

![image-20210727162823543](https://static.fungenomics.com/images/2021/07/image-20210727162823543.png)

![image-20210727163014040](https://static.fungenomics.com/images/2021/07/image-20210727163014040.png)

另一方面，使用cin.get(ch)（有一个参数）进行输入时，将不会导 致任何类型方面的问题。前面讲过，cin.get(char)函数在到达EOF时，不 会将一个特殊值赋给ch。事实上，在这种情况下，它不会将任何值赋给 ch。ch不会被用来存储非char值。

![image-20210727163117901](https://static.fungenomics.com/images/2021/07/image-20210727163117901.png)

那么应使用cin.get( )还是cin.get(char)呢？使用字符参数的版本更符 合对象方式，因为其返回值是istream对象。这意味着可以将它们拼接起 来。例如，下面的代码将输入中的下一个字符读入到ch1中，并将接下 来的一个字符读入到ch2中:

```Cpp
cin.get(ch1).get(ch2);
```

## 5.6 嵌套循环和二维数组

C++没有提供二维数组类型，但用户可以创建每个元素本身都是数 组的数组。可以这样声明数组：

```Cpp

int maxtemps[4][5];
```


![image-20210727163540362](https://static.fungenomics.com/images/2021/07/image-20210727163540362.png)

![image-20210727163623327](https://static.fungenomics.com/images/2021/07/image-20210727163623327.png)

![image-20210727163905902](https://static.fungenomics.com/images/2021/07/image-20210727163905902.png)


假设要打印数组所有的内容，可以用一个for循环来改变行，用另一 个被嵌套的for循环来改变列：

```Cpp
for (int row = 0; row < 4; ++row) {
    for (int col=0; col < 5; ++col) {
        cout << maxtemps[row][col] << "\t";
    }
    cout << endl;
}
```

> 实际上，我更喜欢用 vector 来创建动态二维数据，只要创建 vector 的vector 就行，用起来更简单。

## 5.7 总结

C++提供了3种循环：for循环、while循环和do while循环。如果循环 测试条件为true或非零，则循环将重复执行一组指令；如果测试条件为 false或0，则结束循环。for循环和while循环都是入口条件循环，这意味 着程序将在执行循环体中的语句之前检查测试条件。do while循环是出 口条件循环，这意味着其将在执行循环体中的语句之后检查条件。

关系表达式对两个值进行比较，常被用作循环测试条件。关系表达 式是通过使用6种关系运算符之一构成的：`<`、`<=`、`==`、`>=`、`>` 或 `!=`。 关系表达式的结果为bool类型，值为true或false。


# 第六章 分支语句和逻辑运算符

本章的内容包括：

- `if` 语句；
- `if else` 语句；
- 逻辑运算符：`&&`、`||` 和 `!`；
- `cctype` 字符函数库；
- 条件运算符：`?:`；
- `switch` 语句；
- `continue` 和 `break` 语句；
- 读取数字的循环；
- 基本文件输入/输出。

## 6.1 `if` 语句

如果测试条件为 `true`， 则 `if` 语句将引导程序执行语句或语句块；如果条件是`false`，程序将跳过 这条语句或语句块。因此，`if` 语句让程序能够决定是否应执行特定的语句。

![image-20210728225254330](https://static.fungenomics.com/images/2021/07/image-20210728225254330.png)

### 6.1.1 `if else` 语句

`if` 语句让程序决定是否执行特定的语句或语句块，而`if else`语句则让程序决定执行两条语句或语句块中的哪一条，这种语句对于选择其中一 种操作很有用。

`if else` 语句的通用格式如下：

![image-20210728225544934](https://static.fungenomics.com/images/2021/07/image-20210728225544934.png)

![image-20210728225606236](https://static.fungenomics.com/images/2021/07/image-20210728225606236.png)

### 6.1.2 格式化 `if else` 语句

`if else` 中的两种操作都必须是一条语句。如果需要多条语句，需要 用大括号将它们括起来，组成一个块语句。

### 6.1.3  `if`- `else if`- `else` 结构

计算机程序也可能提供两个以上的 选择。可以将`C++`的 `if else` 语句进行扩展来满足这种需求。正如读者知 道的，`else` 之后应是一条语句，也可以是语句块。由于 `if else` 语句本身是 一条语句，所以可以放在 `else` 的后面。

## 6.2 逻辑表达式

C++ 提供了3种逻辑运算符，来组合或修改已有的表达式。这些运算符分别是逻 辑 `OR (||)`、逻辑 `AND (&&)`和逻辑 `NOT (!)`。

### 6.2.1 逻辑OR运算符：`||`

C++可以采用逻辑OR运算 符 `||`，将两个表达式组合在一起。如果原来表达式中的任何一个或 全部都为 `true`（或非零），则得到的表达式的值为 `true`；否则，表达式的值为 `false`。

C++ 规定 `||` 运算符是个顺序点（sequence point）。也是说，先修改左侧的值，再对右侧的值进行判定（C++11的说法是，运算符左边的子表达式先于右边的子表达式）。

![image-20210728230438579](https://static.fungenomics.com/images/2021/07/image-20210728230438579.png)

### 6.2.2 逻辑AND运算符：`&&`

逻辑AND运算符 `&&`，也是将两个表达式组合成一个表达式。 仅当原来的两个表达式都为 `true` 时，得到的表达式的值才为 `true`。

`&&` 运算符也是顺序点，因此将首先判定左侧， 并且在右侧被判定之前产生所有的副作用。如果左侧为 `false`，则整个逻 辑表达式必定为 `false`，在这种情况下，C++ 将不会再对右侧进行判定。

![image-20210728230605370](https://static.fungenomics.com/images/2021/07/image-20210728230605370.png)

### 6.2.3 用 `&&` 来设置取值范围

`&&` 运算符还允许建立一系列`if` `else if` `else`语句，其中每种选择都对 应于一个特定的取值范围。

### 6.2.4 逻辑NOT运算符：`!`

`!` 运算符将它后面的表达式的真值取反。也是说，如果 `expression` 为 `true`，则 `!expression` 是 `false`；如果 `expression` 为 `false`，则 `!expression`是 `true`。更准确地说，如果 `expression` 为 `true` 或非零，则 `!expression` 为 `false`。

然而，`!` 运算符对于返回 `true-false` 值或可以被解释为 `true-false` 值的函数来说很有用。例如，如果C-风格字符串 `s1` 和 `s2` 不同，则 `strcmp(s1,s2)` 将返回非零`true`值，否则返回 `0`。这意味着如果这两个字符串相同， 则 `!strcmp(s1,s2)` 为 `true`。

### 6.2.5 逻辑运算符细节

`!` 运算符的优先级高于所有的关系运算符和算术运算符。因此，要对表达式求反，必须用括号将其括起。

### 6.2.6 其他表示方式

并不是所有的键盘都提供了用作逻辑运算符的符号，因此C++标准 提供了另一种表示方式，如表6.3所示。标识符`and`、`or`和`not`都是C++保 留字，这意味着不能将它们用作变量名等。它们不是关键字，因为它们 都是已有语言特性的另一种表示方式。另外，它们并不是C语言中的保 留字，但C语言程序可以将它们用作运算符，只要在程序中包含了头文 件 `iso646.h`。C++不要求使用头文件。

![image-20210728232023659](https://static.fungenomics.com/images/2021/07/image-20210728232023659.png)

## 6.3 字符函数库 `cctype`

C++ 从 C 语言继承了一个与字符相关的、非常方便的函数软件包， 它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这 些函数的原型是在头文件`cctype`（老式的风格中为 `ctype.h`）中定义的。 例如，如果 `ch` 是一个字母，则 `isalpha(ch)` 函数返回一个非零值，否则返回 `0`。同样，如果 `ch` 是标点符号（如逗号或句号），函数 `ispunct(ch)` 将返回 `true`。（这些函数的返回类型为 `int`，而不是 `bool`， 但通常 `bool` 转换让您能够将它们视为`bool` 类型。）

![image-20210728232352198](https://static.fungenomics.com/images/2021/07/image-20210728232352198.png)

`isalpha()` 不仅更容易使用，而且更通用。AND/OR格式假设A-Z的 字符编码是连续的，其他字符的编码不在这个范围内。这种假设对于 ASCII码来说是成立的，但通常并非总是如此。

具体地说：

- `isalpha()` 用来检查字符是否为字母字符；
- `isdigits()` 用来测试字符是否为数字字符，如 3；
- `isspace()` 用来测试字符是否为空白，如换行符、空格和制表符；
- `ispunct()` 用来测试字符是否为标点符号。

![image-20210728232647223](https://static.fungenomics.com/images/2021/07/image-20210728232647223.png)

总结一下这个函数包：

![image-20210728232856482](https://static.fungenomics.com/images/2021/07/image-20210728232856482.png)

![image-20210728232930054](https://static.fungenomics.com/images/2021/07/image-20210728232930054.png)

## 6.4 `?:` 运算符

C++有一个常被用来代替 `if else` 语句的运算符，这个运算符被称为条件运算符 `?:`，它是C++中唯一一个需要3个操作数的运算符，也叫 **三目运算符**。

```Cpp
expression1 ? expression2 : expression3
```
如果 `expression1` 为 `true`，则整个条件表达式的值为 `expression2` 的值； 否则，整个表达式的值为 `expression3` 的值。

![image-20210728233356197](https://static.fungenomics.com/images/2021/07/image-20210728233356197.png)

## 6.5 `switch`语句

![image-20210728234430665](https://static.fungenomics.com/images/2021/07/image-20210728234430665.png)

`switch` 语句与 Pascal 等语言中类似的语句之间存在重大的差别。 C++中的 `case` 标签只是行标签，而不是选项之间的界线。也是说，程序跳到 `switch` 中特定代码行后，将依次执行之后的所有语句，除非有明确 的其他指示。程序不会在执行到下一个 `case` 处自动停止，要让程序执行 完一组特定语句后停止，必须使用`break` 语句。这将导致程序跳到 `switch` 后面的语句处执行。

![image-20210728234458366](https://static.fungenomics.com/images/2021/07/image-20210728234458366.png)

### 6.5.1 将枚举量用作标签

通常，`cin` 无法识别枚举类型（它不知道程序员是如 何定义它们的），因此该程序要求用户选择选项时输入一个整数。当 `switch` 语句将 `int` 值和枚举量标签进行比较时，将枚举量提升为 `int`。另 外，在 `while` 循环测试条件中，也会将枚举量提升为 `int` 类型。

### 6.5.2 `switch` 和 `if else`

`switch`语句和`if else`语句都允许程序从选项中进行选择。相比之下， `if else`更通用，例如，它可以处理取值范围。

然而，`switch`并不是为处理取值范围而设计的。`switch`语句中的每 一个`case`标签都必须是一个单独的值。另外，这个值必须是整数（包括 `char`），因此 `switch` 无法处理浮点测试。另外 `case` 标签值还必须是常量。 如果选项涉及取值范围、浮点测试或两个变量的比较，则应使用 `if else` 语句。

## 6.6 `break` 和 `continue` 语句

`break`和 `continue`语句都使程序能够跳过部分代码。可以在 `switch`语句或任何循环中使用 `break` 语句，使程序跳到 `switch` 或循环后面的语句处执行。`continue` 语句用于循环中，让程序跳过循环体中余下的代码，并开始新一轮循环。

![image-20210728235538853](https://static.fungenomics.com/images/2021/07/image-20210728235538853.png)

## 6.7 读取数字的循环

假设要编写一个将一系列数字读入到数组中的程序，并允许用户在 数组填满之前结束输入，一种方法是利用cin。看下面的代码：

```Cpp
int n;
cin >> n;
```

如果用户输入一个单词，而不是一个数字，发生这种类型不匹配的情况时，将发生4种情况：

- `n` 的值保持不变；
- 不匹配的输入将被留在输入队列中；
- `cin` 对象中的一个错误标记被设置；
- 对 `cin` 方法的调用将返回 `false`（如果被转换为 `bool` 类型）。

**方法返回 `false` 意味着可以用非数字输入来结束读取数字的循环**。当用户输入的不是数字时，该程序将不再读取输入。非数字输入设置错误标记意味着必须重置该标记，程序才能继续读取输 入。`clear()` 方法重置错误输入标记，同时也重置文件尾（`EOF`条件，参见第5章）。输入错误和 `EOF` 都将导致`cin`返回 `false`。



![image-20210729001427328](https://static.fungenomics.com/images/2021/07/image-20210729001427328.png)

![image-20210729001350955](https://static.fungenomics.com/images/2021/07/image-20210729001350955.png)

如果用户输入非数字输入，程序将拒绝，并要求用户继续输入数 字。可以看到，可以使用cin输入表达式的值来检测输入是不是数字。 程序发现用户输入了错误内容时，应采取3个步骤：

- 重置 `cin` 以接受新的输入；
- 删除错误输入；
- 提示用户再输入。

请注意，程序必须先重置cin，然后才能删除错误输入。程序清单 6.14演示了如何完成这些工作。

```Cpp
#include <iostream>

const int Max = 5;
int main() {
    using namespace std;
    // get data
    int golf[Max];
    cout << "Please enter your golf scores.\n";
    cout << "You must enter " << Max << " rounds.\n";
    int i;
    for (i = 0; i < Max; i++)
    {
        cout << "round #" << i+1 << ": ";
        while (!(cin >> golf[i])) {
            cin.clear();     // reset input
            while (cin.get() != '\n')
                continue;    // get rid of bad input
                
            cout << "Please enter a number: ";
        }
    }
    
    // calculate average
    double total = 0.0;
    for (i = 0; i < Max; i++)
        total += golf[i];
        
    // report results
    cout << total / Max << " = average score "
         << Max << " rounds\n";
    // cin.get();
    // cin.get();
    return 0;
}
```

![image-20210729165001482](https://static.fungenomics.com/images/2021/07/image-20210729165001482.png)

> 如果用户输入 88，则 `cin` 表达式将为 `true`，因此将一个值放到数组中；而表达式 `!(cin >> golf [i])` 为 `false`，因此结束内部循环。然而，如果用户输入 `must i?`，则 `cin` 表达式将为 `false`，因此不会将任何值放到数组 中；而表达式 `!(cin >> golf [i])` 将为 `true`，因此进入内部的 `while` 循环。该循环的第一条语句使用 `clear()` 方法重置输入，如果省略这条语句，程序将拒绝继续读取输入。接下来，程序在 `while` 循环中使用 `cin.get()` 来读取 行尾之前的所有输入，从而删除这一行中的错误输入。另一种方法是读取到下一个空白字符，这样将每次删除一个单词，而不是一次删除整 行。最后，程序告诉用户，应输入一个数字。

## 6.8 简单文件输入/输出

### 6.8.1 文本I/O和文本文件
### 6.8.2 写入到文本文件中
文件输出：

- 必须包含头文件 `fstream`；
- 头文件 `fstream` 定义了一个用于处理输出的 `ofstream` 类；
- 需要声明一个或多个ofstream变量（对象），并以自己喜欢的方式 对其进行命名，条件是遵守常用的命名规则；
- 必须指明名称空间 `std`；例如，为引用元素 `ofstream`，必须使用编译指令`using` 或前缀 `std::`；
- 需要将 `ofstream` 对象与文件关联起来。为此，方法之一是使用 `open()` 方法；
- 使用完文件后，应使用方法 `close()` 将其关闭；
- 可结合使用 `ofstream` 对象和运算符 `<<` 来输出各种类型的数据。

虽然头文件 `iostream` 提供了一个预先定义好的名为 `cout` 的 `ostream` 对象，但您必须声明自己的 `ofstream` 对象，为其命名，并将其同文件关联起来。

![image-20210729232741786](https://static.fungenomics.com/images/2021/07/image-20210729232741786.png)

注意，方法open( )接受一个C-风格字符串作为参数，这可以是一个 字面字符串，也可以是存储在数组中的字符串。

重要的是，声明一个ofstream对象并将其同文件关联起来后，便可 以像使用cout那样使用它。所有可用于cout的操作和方法（如<<、endl 和setf( )）都可用于ofstream对象（如前述示例中的outFile和fout）。

总之，使用文件输出的主要步骤如下：

- 包含头文件 `fstream`；
- 创建一个 `ofstream` 对象；
- 将该 `ofstream` 对象同一个文件关联起来；
- 就像使用 `cout` 那样使用该 `ofstream` 对象;
- 调用 `close()` 成员函数，关闭文件。

> 默认情况下，`open()` 将首先截断该文件，即将其长度截短到零——丢其原有的内容，然后将新 的输出加入到该文件中。


### 6.8.3 读取文本文件

接下来介绍文本文件输入，它是基于控制台输入的。控制台输入涉 及多个方面，下面首先总结这些方面：

- 必须包含头文件 `fstream`；
- 头文件 `fstream` 定义了一个用于处理输入的 `ifstream` 类；
- 需要声明一个或多个 `ifstream` 变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则；
- 必须指明名称空间 `std`；例如，为引用元素 `ifstream`，必须使用编译指令`using`或前缀`std::`；
- 需要将 `ifstream` 对象与文件关联起来。为此，方法之一是使用 `open()` 方法；
- 使用完文件后，应使用 `close()` 方法将其关闭；
- 可结合使用 `ifstream` 对象和运算符 `>>` 来读取各种类型的数据；
- 可以使用 `ifstream` 对象和 `get()` 方法来读取一个字符，使用 `ifstream` 对象和 `getline()` 来读取一行字符；
- 可以结合使用 `ifstream` 和 `eof()`、`fail()` 等方法来判断输入是否成功；
- `ifstream` 对象本身被用作测试条件时，如果最后一个读取操作成 功，它将被转换为布尔值 `true`，否则被转换为 `false`。

如果试图打开一个不存在的文件用于输入，情况将如何呢？这种错 误将导致后面使用`ifstream` 对象进行输入时失败。检查文件是否被成功打开的首先方法是使用方法`is_open()`，为此，可以使用类似于下面的代码：

```Cpp
inFile.open("b.txt");
if (!inFile.is_open()) {
    exit(EXIT_FEAILURE);
}
```

如果文件被成功地打开，方法 `is_open()` 将返回 `true`；因此如果文件没有被打开，表达式 `!inFile.isopen()` 将为 `true`。函数 `exit()` 的原型是在头文件 `cstdlib` 中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值 `EXIT_FAILURE`。函数 `exit()` 终止程序。

> 方法 `is_open()` 是C++中相对较新的内容。如果读者的编译器不支持它，可使用较老的方法 `good()` 来代替。

程序例子：

![image-20210730001839791](https://static.fungenomics.com/images/2021/07/image-20210730001839791.png)![image-20210730001922821](https://static.fungenomics.com/images/2021/07/image-20210730001922821.png)

假设该文件名为scores.txt，包含的内容如下：

```bash
18 19 18.5 13.5
16 19.5 18.5
17.5
```

> 检查文件是否被成功打开至关重要。

读取文件时，有 几点需要检查。首先，程序读取文件时不应超过EOF。如果最后一次读 取数据时遇到 `EOF`，方法 `eof()` 将返回 `true`。其次，程序可能遇到类型不 匹配的情况。例如，程序清单6.16期望文件中只包含数字。如果最后一次读取操作中发生了类型不匹配的情况，方法 `fail()` 将返回 `true`（如果遇到了 `EOF`，该方法也将返回 `true`）。最后，可能出现意外的问题，如文 件受损或硬件故障。如果最后一次读取文件时发生了这样的问题，方法 `bad()` 将返回 `true`。不要分别检查这些情况，一种更简单的方法是使用 `good()` 方法，该方法在没有发生任何错误时返回 `true`：

```Cpp
while (inFile.good()) {
    ......
}
```

方法 `good()` 指出最后一次读取输入的操作是否成功，这一点至关重要。这意味着应该在执行读取输入的操作后，立刻应用这种测试。为此，一种标准方法是，在循环之前（首次执行循环测试前）放置一条输 入语句，并在循环的末尾（下次执行循环测试之前）放置另一条输入语句：

```Cpp
// standard file-reading loop design
inFile >> value;         // get first value
while (inFile.good()) {  // while uput good and not at EOF
    //loop body goes here
    inFile >> value;     // get next value
}
```

鉴于以下事实，可以对上述代码进行精简：表达式 `inFile >> value` 的结果为`inFile`，而在需要一个 `bool` 值的情况下，`inFile` 的结果为 `inFile.good()`，即 `true` 或 `false`。

因此，可以将两条输入语句用一条用作循环测试的输入语句代替。 也就是说，可以将上述循环结构替换为如下循环结构：

```Cpp
// omit pre-loop input
while (inFile >> value) {  // read and test for success
    // loop body goes here
    // omit end-of-loop input
}
```

![image-20210730002759125](https://static.fungenomics.com/images/2021/07/image-20210730002759125.png)

这些代码紧跟在循环的后面，用于判断循环为何终止。由于 `eof()` 只能判断是否到达 `EOF`，而 `fail()` 可用于检查 `EOF` 和类型不匹配，因此上述 代码首先判断是否到达 `EOF`。这样，如果执行到了 `else if` 测试，便可排除 `EOF`，因此，如果 `fail()` 返回 `true`，便可断定导致循环终止的原因是类型不匹配。

这种设计仍然遵循了在测试之前进行读取的规则，因为要计算表达式 `inFile >> value` 的值，程序必须首先试图将一个数字读取到 `value` 中。

以上仅是对文件 I/O 的初步介绍。


## 6.9 总结

C++提供了 `if` 语句、`if else`语句和 `switch` 语句来管理选项。
C++还提供了帮助决策的运算符。通过使用逻辑运算符（`&&`、`||` 和 `!`），可以组合或修改关系表达式，创建更细致的测试。条件运算符 `(?:)` 提供了一种选择两个值之一 的简洁方式。

`cctype` 字符函数库提供了一组方便的、功能强大的工具，可用于分析字符输入。

![image-20210728232856482](https://static.fungenomics.com/images/2021/07/image-20210728232856482.png)
![image-20210728232930054](https://static.fungenomics.com/images/2021/07/image-20210728232930054.png)

文件I/O与控 制台I/O极其相似。声明ifstream和ofstream对象，并将它们同文件关联起 来后，便可以像使用cin和cout那样使用这些对象。



# 第七章 函数——C++的编程模块

本周内容包括：

- 函数基本知识；
- 函数原型；
- 按值传递函数参数；
- 设计处理数据的函数；
- 使用 `const` 指针参数；
- 设计处理文本字符串的函数；
- 设计处理结构的函数；
- 设计处理 `string` 对象的函数；
- 调用自身的函数（递归）；
- 指向函数的指数。

## 7.1 函数基本知识

自定义函数三要素：
- 函数定义；
- 函数原型；
- 调用函数。 


### 7.1.1 定义函数

函数定义通用格式：

```Cpp
void functionName(parameterList) {
    statement(s);
    return;
}
```
C++ 对于返回值的类型有一定的限制：**不能是数组**，但可以是其他任何类型——整数、浮点数、指针，甚至可以是结构体和对象。


**C++ 函数返回值的原理是什么？**
首先，函数将返回值复制到指定的CPU寄存器或内存单元中将值返回；随后，调用程序将查看该内存单元。返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致。函数原型将返回值 类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。

![image-20210804133448677](https://static.fungenomics.com/images/2021/08/image-20210804133448677.png)

### 7.1.2 函数原型和函数调用

1. 为什么需要函数原型

原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。举个例子：

```Cpp
double volume = cube(side);
```

首先，原型告诉编译器，cube( )有一个double参数。如果程序没有 提供这样的参数，原型将让编译器能够捕获这种错误。其次，cube( )函 数完成计算后，将把返回值放置在指定的位置——可能是CPU寄存器， 也可能是内存中。然后调用函数（这里为main( )）将从这个位置取得返 回值。由于原型指出了cube( )的类型为double，因此编译器知道应检索 多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行 猜测，而编译器是不会这样做的。

为何编译器需要原型，它就不能在文件中进一步查找，以了解函数是如何定义的吗？这种方法的一个问题是效率不高。编译器在搜索文件的剩余部分时必须停止对 `main()` 的编译。一个更严重的问题是，函数甚至可能并不在文件中。C++允许将一个程序放 在多个文件中，单独编译这些文件，然后再将它们组合起来。在这种情 况下，编译器在编译`main()`时，可能无权访问函数代码。如果函数位于库中，情况也将如此。避免使用函数原型的唯一方法是，在首次使用函 数之前定义它，但这并不总是可行的。

2. 原型的语法

函数原型是一条语句，因此必须以分号结束。获得原型最简单的方 法是，复制函数定义中的函数头，并添加分号。
函数原型不要求提供变量名，有类型列表就足够了。**通常，在原型的参数列表中，可以包括变量名，也可以不包括。原 型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。**

3. 原型的功能

它们可以极大地降低程序出错的几率。具体来说，原型 确保以下几点：

- 编译器正确处理函数返回值；
- 编译器检查使用的参数数目是否正确；
- 编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型。

![image-20210804144730761](https://static.fungenomics.com/images/2021/08/image-20210804144730761.png)

仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构或指针。

在编译阶段进行的原型化被称为静态类型检查（static type checking）。

## 7.2 函数参数和按值传递

C++通常按值传递参数，这意味着将 数值参数传递给函数，而后者将其赋给一个新的变量。

```Cpp
double volume = cube(side);
```



![image-20210804145401521](https://static.fungenomics.com/images/2021/08/image-20210804145401521.png)

side 是一个变量，被调用时，该函数将创建一个新的名为x的double变量，并将其初 始化为5。这样，cube( )执行的操作将不会影响main( )中的数据，因为 cube( )使用的是side的副本，而不是原来的数据。

**在函数中声明的变量（包括参数）是该函数私有的。在函数被调用 时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些 变量使用的内存**。这样的变量被称为局部变量，因为它们被限制在函数中。前面提到过，这样做有助于确保数据的完整性。这还意 味着，如果在main( )中声明了一个名为x的变量，同时在另一个函数中 也声明了一个名为x的变量，则它们将是两个完全不同的、毫无关系的变量。

![image-20210804145526933](https://static.fungenomics.com/images/2021/08/image-20210804145526933.png)

### 7.2.1 多个参数

函数可以有多个参数。在调用函数时，只需使用逗号将这些参数分开即可。

![image-20210804150422862](https://static.fungenomics.com/images/2021/08/image-20210804150422862.png)

它使用`cin>>ch`，而不是`cin.get(ch)`或`ch = cin.get()`来读取一个字符。这样做是有原因的。前面讲过，这两个`cin.get()` 函数读取所有的输入字符，包括空格和换行符，而 `cin>>` 跳过空格和换行符。当用户对程序提示作出响应时，必须在每行的最后按 `Enter` 键，以生成换行符。`cin>>ch` 方法可以轻松地**跳过这些换行符**，但当输入的下一个字符为数字时，`cin.get()` 将读取后面的换行符，虽然可以通过编程来避开这种麻烦，但比较简便的方法是像该程序那样使用 `cin`。

## 7.3 函数和数

需要将数组名作为参数传递给它，为使函数通用，而不限于特定长度的数组，还需要传递数组长度。

```Cpp
int sum_arr(int arr[], int n);
```

方括号指出 `arr` 是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数。但实际情况并非如此：`arr`实际上并不是数组，**而是一个指针**，好消息是，在编写函数的其余部分时，可以将 `arr` 看作是数组。

### 7.3.1 函数如何使用指针来处理数组

在大多数情况下，C++和C语言一样，也将数组名视为指针。C++将数组名解释为其第一个元素的地址：

```Cpp
cookies == &cookies[0];   // array name is the address of first element
```

首先，数组声明使用数组名来标记存储位置； 其次，对数组名使用sizeof将得到整个数组的长度（以字节为单位）； 第三，正如第4章指出的，将地址运算符&用于数组名时，将返回整个数组的地址。

![image-20210804152348446](https://static.fungenomics.com/images/2021/08/image-20210804152348446.png)

以下两个语句是恒等的：

```Cpp
arr[i] == *(arr+i);  // values in two notations
&arr[i] == arr + i;  // addresses in two notations
```

### 7.3.2 将数组作为参数意味着什么

传递常规变量时，函数将使用该变量的拷 贝；但传递数组时，函数将使用原来的数组。实际上，这种区别并不违反C++按值传递的方法，`sum_arr()` 函数仍传递了一个值，这个值被赋给 一个新变量，但这个值是一个地址，而不是数组的内容。

![image-20210804154353723](https://static.fungenomics.com/images/2021/08/image-20210804154353723.png)

**将数组地址作为参数可以节省复制整个数组所需的时间和内存**。如果数组很大，则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。另一方面，使用原始数据增加了破坏数据的风险。

`sum_arr(cookies+4, 4)` 和 `sum_arr(&cookies[4], 4)` 是等效的。

![image-20210804155245012](https://static.fungenomics.com/images/2021/08/image-20210804155245012.png)



### 7.3.3 更多数组函数示

1．填充数组

2．显示数组及用const保护数组

创建显示数组内容的函数很简单。只需将数组名和填充的元素数目传递给函数，然后该函数使用循环来显示每个元素。然而，还有另一个问题——确保显示函数不修改原始数组。除非函数的目的就是修改传递 给它的数据，否则应避免发生这种情况。使用普通参数时，这种保护将自动实现，这是由于C++按值传递数据，而且函数使用数据的副本。然 而，接受数组名的函数将使用原始数据，这正是fill_array( )函数能够完 成其工作的原因。为防止函数无意中修改数组的内容，可在声明形参时 使用关键字`const`：

```Cpp
void show_array(const double arr[], int n);
```
`show_array()` 将数组视为只读数据。

3．修改数组

在这个例子中，对数组进行的第三项操作是将每个元素与同一个重新评估因子相乘。需要给函数传递3个参数：因子、数组和元素数目。 该 **函数不需要返回值**，因此其代码如下：

```Cpp
void revalue(double r, double arr[], int n) {
    for (int i=0; i < n; ++i) {
        arr[i] *= r;
    }
}
```
由于这个函数将修改数组的值，因此在声明 `arr` 时，不能使用 `const`。

4．将上述代码组合起来


前面已经讨论了与该示例相关的重要编程细节，因此这里回顾一下 整个过程。我们首先考虑的是通过数据类型和设计适当的函数来处理数 据，然后将这些函数组合成一个程序。有时也称为自下而上的程序设计 （bottom-up programming），因为设计过程从组件到整体进行。这种方 法非常适合于OOP——它首先强调的是数据表示和操纵。而传统的过程性编程倾向于从上而下的程序设计（top-down programming），首先指 定模块化设计方案，然后再研究细节。这两种方法都很有用，最终的产 品都是模块化程序。

6．数组处理函数的常用编写方式

假设要编写一个处理double数组的函数。如果该函数要修改数组， 其原型可能类似于下面这样：

```Cpp
void f_modfiy(double arr[], int n);
```

如果函数不修改数组，其原型可能类似于下面这样：

```Cpp
void _f_no_change(const double arr[], int n);
```

### 7.3.4 使用数组区间的函数

对于处理数组的C++函数，必须将数组中的数据种 类、数组的起始位置和数组中元素数量提交给它；传统的C/C++方法 是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数据类型），这样便给函数提供了找到所有 数据所需的信息。

还有另一种给函数提供所需信息的方法，即指定元素区间 （range），这可以通过传递两个指针来完成：**一个指针标识数组的开头，另一个指针标识数组的尾部**。

![image-20210804170600111](https://static.fungenomics.com/images/2021/08/image-20210804170600111.png)

它将 `pt` 设置为指向要处理的第一个元素（`begin`指向的元素）的指针，并将`*pt`（元素的值）加入到 `total` 中。然后，循环通过递增操作来更新 `pt`，使之指向下一个元素。只要 `pt` 不等于 `end`，这一过程就将继续下去。当 `pt` 等于 `end` 时，它将指向区间中最后一个元素后面的一个位置，此时循环将结束。

### 7.3.5 指针和 `const`

将const用于指针有一些很微妙的地方，可以用两种不同的方式将 `const` 关键字用于指针。 第一种方法是让指针指向一个常量对象，这样可以防止使用该指针来修改所指向的值，第二种方法是将指针本身声明为常量，这样可以防止改变指针指向的位置。

![image-20210804171314723](https://static.fungenomics.com/images/2021/08/image-20210804171314723.png)

![image-20210804171334907](https://static.fungenomics.com/images/2021/08/image-20210804171334907.png)

现在来看一个微妙的问题。pt的声明并不意味着它指向的值实际上 就是一个常量，而只是意味着对pt而言，这个值是常量。例如，pt指向age，而age不是const。可以直接通过age变量来修改age的值，但不能使 用pt指针来修改它。

![image-20210804171429933](https://static.fungenomics.com/images/2021/08/image-20210804171429933.png)

![image-20210804171526205](https://static.fungenomics.com/images/2021/08/image-20210804171526205.png)

C++禁止第二种情况的原因很简单——如果将g_moon的地 址赋给pm，则可以使用pm来修改g_moon的值，这使得g_moon的const 状态很荒谬，因此C++禁止将const的地址赋给非const指针。

**假设有一个由const数据组成的数组则禁止将常量数组的地址赋给非常量指针将意味着不能将数组名作 为参数传递给使用非常量形参的函数。**

只要条件允许，则应将指针形参声明为指向 `const` 的指针。

> **尽可能使用const**: 
> 将指针参数声明为指向常量数据的指针有两条理由：
> -  这样可以避免由于无意间修改数据而导致的编程错误；
> - 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。

`const` 只能防止修改 `pt` 指向的值（这里为39），而不能防止修改 `pt` 的值。也就是说，可以将一个新地址赋给 `pt`。

第二种使用const的方式使得无法修改指针的值：



![image-20210804172355209](https://static.fungenomics.com/images/2021/08/image-20210804172355209.png)

![image-20210804172525799](https://static.fungenomics.com/images/2021/08/image-20210804172525799.png)

通常，将指针作为函数参数来传递时，可以使用指向`const`的指针来 保护数据。

在该声明中使用 `const` 意味着 `show_array()` 不能修改传递给它的数组中的值。只要只有一层间接关系，就可以使用这种技术。例如，这里的数组元素是基本类型，但如果它们是指针或指向指针的指针，则不能使用 `const`。

## 7.4 函数和二维数组

数组名被视为其地 址，因此，相应的形参是一个指针，就像一维数组一样。

`Data` 是一个数组名，该数组有3个元素。第一个元素本身是一个数组，由4个 `int` 值组成。因此 `data` 的类型是指向由4个 `int` 组成的数组的指针，因此正确的原型如下：

```Cpp
int sum(int (*ar2)[4], int size);
```

还有另外一种格式，这种格式与上述原型的含义完全相同，但可读性更强：

```Cpp
int sum(int ar2[][4], int size);
```

对于二维数据，必须对指针 `ar2` 执行两次解除引用，才能得到数据。最简单的方法是使用方括号两次：`ar2[r][c]`。然而，如果不考虑难看的话，也可以使用运算符`*`两次：

```Cpp
ar2[r][c] == *(*(ar2+r)+c);   // 等效
```

## 7.5 函数和C-风格字符串

C-风格字符串由一系列字符组成，以空值字符（`\0`）结尾。

### 7.5.1 将C-风格字符串作为参数的函数

![image-20210804204604444](https://static.fungenomics.com/images/2021/08/image-20210804204604444.png)

假设要将字符串作为参数传递给函数，则表示字符串的方式有三 种：

- `char` 数组；
- 用引号括起的字符串常量（也称字符串字面值）；
- 被设置为字符串的地址的`char`指针。

但上述3种选择的类型都是`char`指针（准确地说是`char*`），因此可 以将其作为字符串处理函数的参数。

![image-20210804214230755](https://static.fungenomics.com/images/2021/08/image-20210804214230755.png)

可以说是将字符串作为参数来传递，**但实际传递的是字符串第一个 字符的地址**。这意味着字符串函数原型应将其表示字符串的形参声明为 `char *` 类型。

C-风格字符串与常规 `char` 数组之间的一个重要区别是，字符串有内置的结束字符。这意味着不必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空值字符为止。

> 不以空值字符结尾的char数组只是数组，而不是字符串。


### 7.5.2 返回C-风格字符串的函数

函数无法返回一 个字符串，但可以返回字符串的地址，这样做的效率更高。
这种设计（让函数返回一个指针，该指针指向new分配的内存）的缺点是，程序员必须记住使用 `delete`。

## 7.6 函数和结构体

**结构体变量的行为更接近于基本的单值变量**。也就是说，与数组不同，结构体将其数据组合成单个实体或数据对象，该实体被视为一个整体。前面讲过，可以将一个结构体赋给另外一个结构体。同样，也**可以按值传递结构体，就像普通变量那样**。在这种情况下，函数将使用原始结构体的副本。另外，函数也可以返回结构体。**与数组名就是数组第一个元素的地址不同的是，结构体名只是结构体的名称，要获得结构的地址，必须使用地址运算符 `&`**。

使用结构编程时，最直接的方式是像处理基本类型那样来处理结构体；也就是说，将结构体作为参数传递，并在需要时将结构体用作返回值使用。

### 7.6.1 传递和返回结构体

当结构体比较小时，按值传递结构体最合理。

### 7.6.2 另一个处理结构的函数示例
### 7.6.3 传递结构体的地址
假设要传递结构的地址而不是整个结构以节省时间和空间，则需要 重新编写前面的函数，使用指向结构的指针。首先来看一看如何重新编写 `show_polar()` 函数。需要修改三个地方：

- 调用函数时，将结构的地址（`&pplace`）而不是结构本身（`pplace`） 传递给它；
- 将形参声明为指向 `polar` 的指针，即`polar *`类型。由于函数不应该修改结构，因此使用了 `const` 修饰符；
- 由于形参是指针而不是结构，因此应间接成员运算符（`->`），而不是成员运算符（句点）。

## 7.7 函数和 `string` 对象

可以将对象作为完整的实体进行传递，如果需要多个字符串，可以声明一个`string` 对象数组，而不是二维 `char` 数组。

## 7.8 函数与 `array` 对象

## 7.9 递归
C++函数有一种有趣的特点——可 以调用自己，但不允许main()调用自己，这种功能称为递归。

> 我不喜欢递归，太耗资源，可读性还差。

### 7.9.1 包含一个递归调用的递归
### 7.9.2 包含多个递归调用的递归


## 7.10 函数指针

与数据项相似，函数也有地址。函数的地址是存储其机器语言代码 的内存的开始地址。对程序而言很有用，可以编写将另一个函数的地址作为参数的函数。

这样第一个函数将能够找到第二个函数，并运行 它。与直接调用另一个函数相比，这种方法很笨拙，但它允许在不同的 时间传递不同函数的地址，这意味着可以在不同的时间使用不同的函数。

### 7.10.1 函数指针的基础知识

1．获取函数的地址
获取函数的地址很简单：只要使用函数名（后面不跟参数）即可。。要将函数作为参数进行传递，必须传递函数名，要区分传递的是函数的地址还是函数的返回值。

2．声明函数指针

声明指向函数的指针时，必须指定指针指向的函数类型。意味着声明应指定函数的返回类型以及函数的特征标（参数列表）。也就是说，声明应像函数原型那样指出有关函数的信息：

![image-20210805084458826](https://static.fungenomics.com/images/2021/08/image-20210805084458826.png)

3．使用指针来调用函数

![image-20210805084920592](https://static.fungenomics.com/images/2021/08/image-20210805084920592.png)

> 为何pf和`(*pf`等价呢？一种学派认为，由于pf是函数指针，而 `*pf` 是函数，因此应将`(*pf)()`用作函数调用。另一种学派认为，由于函数名是指向该函数的指 针，指向函数的指针的行为应与函数名相似，因此应将pf( )用作函数调用使用。C++进行了折 衷——这2种方式都是正确的，或者至少是允许的，虽然它们在逻辑上是互相冲突的。在认为 这种折衷粗糙之前，应该想到，容忍逻辑上无法自圆其说的观点正是人类思维活动的特点。
> 

![image-20210805085227934](https://static.fungenomics.com/images/2021/08/image-20210805085227934.png)

可能看起来比较深奥，但指向函数指针数组的指针并不少见。实际上，类的虚方法实现通常都采用了这种技术（参见第13章）。

### 7.10.4 使用typedef进行简化

这里采用的方法是，将别名当做标识符进行声明，并在开头使用关键字 `typedef`。
使用typedef可减少输入量，让您编写代码时不容易犯错，并让程序 更容易理解。

### 7.11 总结

函数是C++的编程模块。要使用函数，必须提供定义和原型，并调 用该函数。函数定义是实现函数功能的代码；函数原型描述了函数的接 口：传递给函数的值的数目和种类以及函数的返回类型。函数调用使得 程序将参数传递给函数，并执行函数的代码。

C++提供了3种表示C-风格字符串的方法：字符数组、字符串常量 和字符串指针。它们的类型都是`char*`（`char`指针），因此被作为`char*`类型参数传递给函数。C++使用空值字符 `\0` 来结束字符串，因此字符 串函数检测空值字符来确定字符串的结尾。

C++处理结构体的方式与基本类型完全相同，这意味着可以按值传递结构体，并将其用作函数返回类型。然而，如果结构体非常大，则传递结构体指针的效率将更高，同时函数能够使用原始数据。



# 第八章 函数探幽

本章内容：

- 内联函数；
- 引用变量；
- 如何按引用传递函数参数；
- 默认参数；
- 函数重载；
- 函数模板；
- 函数模板具体化。

## 8.1 C++ 内联函数

内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它 们组合到程序中。 常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。

C++内联函数提供了另一种选择。内联函数的编译代码与其他程序 代码“内联”起来了。也就是说，编译器将使用相应的函数代码替换函数 调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。

![image-20210805155012304](https://static.fungenomics.com/images/2021/08/image-20210805155012304.png)

要使用这项特性，必须采取下述措施之一：

- 在函数声明前加上关键字 inline；
- 在函数定义前加上关键字 inline；

内联函数最好都是一些很简单、行数少的函数。

## 8.2 引用变量

C++新增了一种复合类型——引用变量。引用是已定义的变量的别 名（另一个名称）。

### 8.2.1 创建引用变量

C++给`&`符号赋 予了另一个含义，将其用来声明引用。例如，要将 `rodents`作为`rats`变量的别名，可以这样做：

```Cpp
int rats;
int &rodents = rats;  // makes rodents an alias for rats
```

其中，**`&` 不是地址运算符，而是类型标识符的一部分**。就像声明中的 `char*` 指的是指向 `char` 的指针一样，`int &` 指的是指向 `int` 的引用。

将 `rodents` 加1将影响这两个变量。更准确地说， `rodents++` 操作将一个有两个名称的变量加1。

引用看上去很像伪装表示的指针（其中，`*` 解除引用运算符被隐式理解）。实际上，引用还是不同 于指针的。除了表示法不同外，还有其他的差别。例如，差别之一是， 必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值。

![image-20210805160617225](https://static.fungenomics.com/images/2021/08/image-20210805160617225.png)

引用更接近const指针，必须在创建时进行初始化，一旦与某个变量 关联起来，就将一直效忠于它。也就是说：某个变量的引用是不可更改的。

**引用是别名**

### 8.2.2 将引用用作函数参数

引用经常被用作函数参数，使得函数中的变量名成为调用程序中的 变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被 调用的函数能够访问调用函数中的变量。C++新增的这项特性是对C语 言的超越，C语言只能按值传递。按值传递导致被调用函数使用调用程 序的值的拷贝（参见图8.2）。

![image-20210805161500948](https://static.fungenomics.com/images/2021/08/image-20210805161500948.png)

交换函数必须能够修改调用程序中的 变量的值。这意味着按值传递变量将不管用，因为函数将交换原始变量 副本的内容，而不是变量本身的内容。但传递引用时，函数将可以使用 原始数据。另一种方法是，传递指针来访问原始数据。

![image-20210805162214166](https://static.fungenomics.com/images/2021/08/image-20210805162214166.png)

![image-20210805162432252](https://static.fungenomics.com/images/2021/08/image-20210805162432252.png)

### 8.2.3 引用的属性和特别之处
`refcube()` 函数修改了 `main()` 中的 `x` 值，而 `cube()` 没有，这提醒我们为何通常按值传递。变量 `a` 位于 `cube()` 中，它被初始化为 `x` 的值，但修改 `a` 并不会影响 `x`。但由于 `refcube()` 使用了引用参数，因此修改 `ra` 实际上就是修改 `x`。如果只是让函数使用传递给它的信息，而不对这些信 息进行修改，同时又想使用引用，则应使用常量引用。

例如，在这个例子中，应在函数原型和函数头中使用`const`：

```Cpp
double refcube(const double &ra);
```

如果要编写类似于上述示例的函数（即使用基本数值 类型），应采用按值传递的方式，而不要采用按引用传递的方式。当数 据比较大（如结构和类）时，引用参数将很有用。

![image-20210805163836749](https://static.fungenomics.com/images/2021/08/image-20210805163836749.png)

### 8.2.4 将引用用于结构体

![image-20210805164836645](https://static.fungenomics.com/images/2021/08/image-20210805164836645.png)

2．为何要返回引用

下面更深入地讨论返回引用与传统返回机制的不同之处。传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而 调用程序将使用这个值。

> 返回引用的函数实际上是被引用的变量的别名。

3．返回引用时需要注意的问题

返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。应**避免**编写如下代码：

![image-20210805165912018](https://static.fungenomics.com/images/2021/08/image-20210805165912018.png)

**该函数返回一个指向临时变量（newguy）的引用，函数运行完毕后 它将不再存在。同样，也应避免返回 指向临时变量的指针。**

为避免这种问题，最简单的方法是，返回一个作为参数传递给函数 的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用 也将指向这些数据。

4．为何将const用于引用返回类型

### 8.2.5 将引用用于类对象

将类对象传递给函数时，C++通常的做法是使用引用。

![image-20210805171059802](https://static.fungenomics.com/images/2021/08/image-20210805171059802.png)

### 8.2.6 对象、继承和引用

### 8.2.7 何时使用引用参数

使用引用参数的主要原因有两个:

- 能够修改调用函数中的数据对象;
- 通过传递引用而不是整个数据对象，可以提高程序的运行速度。

当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于 指针的代码的另一个接口。

使用引用的原则：

![image-20210805171441141](https://static.fungenomics.com/images/2021/08/image-20210805171441141.png)

## 8.3 默认参数 

默认参数指的是当函 数调用中省略了实参时自动使用的一个值。例如：

```Cpp
char * left(const char *str, int n=1);
```

对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值：

```Cpp
int harpo(int n, int m=4, int j=5);      // Valid
int chico(int n, int m=6, int j);        // IN-Valid
int groucho(int k=1, int m=2, int n=3);  // Valid
```
实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。

**默认参数只在声明函数的时候给出，定义函数时，则不需要给出**。

![image-20210807220518596](https://static.fungenomics.com/images/2021/08/image-20210807220518596.png)

![image-20210807220537984](https://static.fungenomics.com/images/2021/08/image-20210807220537984.png)

## 8.4 函数重载

函数多态是C++在C语言的基础上新增的功能。默认参数让您能够 使用不同数目的参数调用同一个函数，而函数多态（函数重载）让您能够使用多个同名的函数，这称为函数重载，它们 完成相同的工作，但使用不同的参数列表。

函数重载的关键是函数的参数列表——也称为函数特征标 （function signature）。

如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。 C++允许定义名称相同的函数，条件是它们的特征标不同。

![image-20210807221358552](https://static.fungenomics.com/images/2021/08/image-20210807221358552.png)

一些看起来彼此不同的特征标是不能共存的。例如，请看下面的两 个原型：

```Cpp
double cube(double x);
double cube(double &x);
```
可能认为可以在此处使用函数重载，因为它们的特征标看起来不 同。然而，请从编译器的角度来考虑这个问题。假设有下面这样的代码：

```Cpp
cout << cube(x);
```

参数 `x` 与 `double x` 原型和 `double &x` 原型都匹配，因此编译器无法确 定究竟应使用哪个原型。为避免这种混乱，**编译器在检查函数特征标 时，将把类型引用和类型本身视为同一个特征标**。

请记住，**是特征标(即，函数特征列表)，而不是函数类型使得可以对函数进行重载**。 例 如，下面的两个声明是互斥的：

```Cpp
long gronk(int n, float m);    // same signatures,
double gronk(int n, float m);  // hence not allowed
```

因此，C++不允许以这种方式重载gronk( )。返回类型可以不同，但 特征标也必须不同。

匹配函数时，并不区分`const`和非`const`变量。看下面的原型：

```Cpp
void dribble(char *bits);         // overloaded
void dribble(const char *cbits);  // overloaded
void dabble(char *bits);          // not overloaded
void drivel(const char *bits);    // not overloaded
```
### 8.4.1 函数重载示例
### 8.4.2 何时使用函数重载

虽然函数重载很吸引人，但也不要滥用。仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。

## 8.5 函数模板

现在的C++编译器实现了C++新增的一项特性——函数模板。函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型（如`int`或`double`）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型（parameterized types）。

![image-20210807224625424](https://static.fungenomics.com/images/2021/08/image-20210807224625424.png)

第一行指出，要建立一个模板，并将类型命名为 `AnyType`。关键字 `template`和 `typename` 是必需的，除非可以使用关键字 `class` 代替 `typename`。 另外，**必须使用尖括号**。类型名可以任意选择（这里为 `AnyType`），只要遵守C++命名规则即可；许多程序员都使用简单的名称，如 `T`。

模板并不创建任何函数，而 只是告诉编译器如何定义函数。需要交换`int`的函数时，编译器将按模板 模式创建这样的函数，并用`int`代替`AnyType`。同样，需要交换`double`的函数时，编译器将按模板模式创建这样的函数，并用`double`代替 `AnyType`。

最终 的代码不包含任何模板，而只包含了为程序生成的实际函数。使用模板 的好处是，它使生成多个函数定义更简单、更可靠。

![image-20210807225139508](https://static.fungenomics.com/images/2021/08/image-20210807225139508.png)

`typename`关键字使得参数`AnyType`表示类型这一点更为明显；然而，有大量代码库是使用关键字class开发的。在这种上下文中，**这两个关键字是等价的**。

需要多个对不同类型使用同一种算法的函数时，可使用模板。

### 8.5.2 模板的局限

- 下面的代码假定定义了赋 值，但如果T为数组，这种假设将不成立；
- 下面的语句假设定义了 `<`，但如果T为结构，该假设便不成立；另外，为数组名定义了运算符 `>`，但由于数组名为地址，因此它比较的是数组的地址，而这可能不是您希望的。

总之，编写的模板函数很可能无法处理某些类型。另一方面，有时 候通用化是有意义的，但C++语法不允许这样做。

### 8.5.3 显式具体化

> 由于C++允许将一个结构赋给另一个结构，因此即使T是一个`job`结构，上述代码也适用。然而，假设只想交换 `salary` 和 `floor` 成员，而不交 换 `name` 成员，则需要使用不同的代码，但 `Swap()` 的参数将保持不变 （两个 `job` 结构的引用），因此无法使用模板重载来提供其他的代码。

- 对于给定的函数名，可以有非模板函数、模板函数和显式具体化模 板函数以及它们的重载版本；
- 显式具体化的原型和定义应以 `template<>` 打头，并通过名称来指出 类型；
- 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。

如果有多个原型，则编译器在选择原型时，**非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本**。

![image-20210808001952681](https://static.fungenomics.com/images/2021/08/image-20210808001952681.png)

![image-20210808002201785](https://static.fungenomics.com/images/2021/08/image-20210808002201785.png)

### 8.5.4 实例化和具体化

为进一步了解模板，必须理解术语实例化和具体化。记住，在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例（instantiation）。

函数调用`Swap(i,j`)导致编译器生成`Swap()`的一个实例，该实例使用`int`类型。**模板并非函数定 义，但使用int的模板实例是函数定义**。这种实例化方式被称为隐式实例 化（implicit instantiation），因为编译器之所以知道需要进行定义，是 由于程序调用Swap( )函数时提供了int参数。

最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但现在C++还允许显式实例化（explicit instantiation）。这意味着可以直接 命令编译器创建特定的实例，如`Swap<int>()`。其语法是，声明所需的种类——用`<>`符号指示类型，并在声明前加上关键字 `template`：

```Cpp
template void Swap<int>(int, int);  // explicit instantiation
```
实现了这种特性的编译器看到上述声明后，将使用`Swap()`模板生成 一个使用`int`类型的实例。也就是说，该声明的意思是“使用`Swap()`模板生成`int`类型的函数定义“。

与显式实例化不同的是，显式具体化使用下面两个等价的声明之 一：

```Cpp
template <> void Swap<int>(int &, int &);
template <> void Swap(int &, int &);
```
区别在于，这些声明的意思是“不要使用 `Swap()` 模板来生成函数定 义，而应使用专门为 `int` 类型显式地定义的函数定义”。这些原型必须有自己的函数定义。**显式具体化声明在关键字 `template` 后包含 `<>`，而显式实例化没有**。

隐式实例化、显式实例化和显式具体化统称为具体化 （specialization）。它们的相同之处在于，它们表示的都是使用具体类 型的函数定义，而不是通用描述。

引入显式实例化后，必须使用新的语法——在声明中使用前缀`template`和`template <>`，以区分显式实例化和显式具体化。通常，功能 越多，语法规则也越多。下面的代码片段总结了这些概念：

![image-20210808202129389](https://static.fungenomics.com/images/2021/08/image-20210808202129389.png)

### 8.5.5 编译器选择使用哪个函数版本

对于函数重载、函数模板和函数模板重载，C++需要（且有）一个 定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多 个参数时。这个过程称为重载解析（overloading resolution）: 

- 第1步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。
- 第2步：使用候选函数列表创建可行函数列表。这些都是参数数目 正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应 的形参类型完全匹配的情况。例如，使用float参数的函数调用可以 将该参数转换为double，从而与double形参匹配，而模板可以为 float生成一个实例;
- 第3步：确定是否有最佳的可行函数。如果有，则使用它，否则该 函数调用出错。

接下来，编译器必须确定哪个可行函数是最佳的。它查看为使函数 调用参数与可行的候选函数的参数匹配所需要进行的转换。通常，从最 佳到最差的顺序如下所述：

- 完全匹配，但常规函数优先于模板；
- 提升转换（例如，char和shorts自动转换为int，float自动转换为 double）；
- 标准转换（例如，int转换为char，long转换为double）；
- 用户定义的转换，如类声明中定义的转换。

### 8.5.6 模板函数的发展
## 8.6 总结

C++扩展了C语言的函数功能。通过将inline关键字用于函数定义， 并在首次调用该函数前提供其函数定义，可以使得C++编译器将该函数 视为内联函数。也就是说，编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用。只有在函数很短时才能采用内联方式。

引用变量是一种伪装指针，它允许为变量创建别名（另一个名称）。引用变量主要被用作处理结构和类对象的函数的参数。

C++原型让您能够定义参数的默认值。如果函数调用省略了相应的 参数，则程序将使用默认值；如果函数调用提供了参数值，则程序将使 用这个值（而不是默认值）。只能在参数列表中从右到左提供默认参数。

函数的特征标是其参数列表。程序员可以定义两个同名函数，只要 其特征标不同。这被称为函数多态或函数重载。

# 第九章 内存模型和名称空间

本章内容包括：

- 单独编译；
- 存储持续性、作用域和链接性；
- 定位（placement）new运算符；
- 名称空间。

## 9.1 单独编译

第1章介绍过，可以单独编译文件，然后将它们链接成可执行的程序。通常，C++编译器既编译程序，也管理链接器。如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接，这使得大程序的管理更便捷。

例如，UNIX和Linux系统都具有make程 序，可以跟踪程序依赖的文件以及这些文件的最后修改时间。运行make 时，如果它检测到上次编译后修改了源文件，make将记住重新构建程序 所需的步骤。

例如但需要将一个结构体在多个文件中复用时，与其将结构体声明加入到每一个文件 中，不如将其放在头文件中，然后在每一个源代码文件中包含该头文件。这样，要修改结构体声明时，只需在头文件中做一次改动即可。另外，也可以将函数原型放在头文件中。因此，可以将原来的程序分成三 部分。

- 头文件：包含结构体声明和使用这些结构体的函数的声明；
- 源代码文件：包含与结构体有关的函数代码；
- 源代码文件：包含调用与结构体相关的函数代码；

这是一种非常有用的组织程序的策略。例如，如果编写另一个程序 时，也需要使用这些函数，则只需包含头文件，并将函数文件添加到项 目列表或make列表中即可。另外，这种组织方式也与OOP方法一致。**一个文件（头文件）包含了用户定义类型的定义；另一个文件包含操纵用 户定义类型的函数的代码。这两个文件组成了一个软件包，可用于各种程序中**。

**不要将函数定义或变量声明放到头文件中**。这样做通常会引来麻烦，因为，如果在头文件包含了一个函数的定义，然后在（同一个程序的）另外两个文件中分别包含了该头文件，那么同一个程序中将包含同一个函数的两个定义，除非函数是内联的，否则这将出错。

头文件常包含的内容：

- 函数原型（也叫函数声明）；
- 使用`#define`或`const`定义的符号常量；
- 结构体声明；
- 类声明；
- 模板声明；
- 内联函数。

将结构体声明放在头文件中是可以的，因为它们不创建变量，而只是在源代码文件中声明结构体变量时，告诉编译器如何创建该结构体变量。同样，模板声明也不是将被编译的代码，它们指示编译器如何生成与源代码中函数调用相匹配的函数定义。被声明为`const`的常量和内联函数有特殊的链接属性（稍后将介绍），因此可以将其放在头文件中，而不会引 起问题。

在包含头文件时，我们使 用`"coordin.h"`，而不是 `<coodin.h>`。如果文件名包含在尖括号中，则 C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，**则编译器将首先查找当前的工作目录或源代码目录（取决于编译器）**，如果没有找到， 则将在标准位置查找。**因此在包含自己的头文件时，应使用引号而不是 尖括号**。

![image-20210810163533843](https://static.fungenomics.com/images/2021/08/image-20210810163533843.png)

> 在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知 情的情况下将头文件包含多次。例如，可能使用包含了另外一个头文件的头文件。有一种标准的C/C++技术可以避免多次包含同一个头文件。它是基于预处理器编译指令#ifndef（即if not defined）的。`#ifndef-#define-#endif` 语句的这种方法**并不能防止编译器将文件包含两次，而只是让它忽略除第一次包含之外的所有内容**。大多数标准C和C++头文件都使用这种防护 （guarding）方案。否则，可能在一个文件中定义同一个结构体、函数、类等两次，这将导致编译错误。

## 9.2 存储持续性、作用域和链接性

存储类别如何影响信息在文件间的共享？

- 自动存储持续性：在**函数定义中声明的变量**（包括函数参数）的存 储持续性为自动的。在程序开始执行其所属的函数或代码块时 被创建，在执行完函数或代码块时，它们使用的内存被释放；
- 静态存储持续性：在函数**定义外**定义的变量和使用关键字`static`定义 的变量的存储持续性都为静态。它们在程序整个运行过程中都存在；
- 线程存储持续性（C++11）：如果变量是使用关键字`thread_local`声明的，则其生命 周期与所属的线程一样长；
- 动态存储持续性：用`new`运算符分配的内存将一直存在，直到使用 `delete`运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。


### 9.2.1 作用域和链接

作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见。链接性（linkage）描述了名称如何在不同单元间共享。链接性为外部的 名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共 享。自动变量的名称没有链接性，因为它们不能共享。

作用域为局部的变量只在定义它的代码 块中可用。**代码块是由花括号括起的一系列语句**。例如函数体就是代码块，但可以在函数体中嵌入其他代码块。作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的。在函数原型作用域（function prototype scope）中使用的名称只在包含参数列表的括号内可用（**这就是为什么这些名称是什么以及是否出现都不重要的原因**）。在类中声明的成员的作用域为整个类。在名 称空间中声明的变量的作用域为整个名称空间

### 9.2.2 自动存储持续性

在默认情况下，在函数中声明的函数参数和变量的存储持续性为自 动，作用域为局部，没有链接性。

如果在代码块中定义了变量，则该变量的存在时间和作用域将被限 制在该代码块内。例子：

![image-20210811100416035](https://static.fungenomics.com/images/2021/08/image-20210811100416035.png)

![image-20210811100534389](https://static.fungenomics.com/images/2021/08/image-20210811100534389.png)

1．自动变量的初始化
2．自动变量和栈

由于自动变量的数目随函数的开始和结束而增减，因此程序必须 在运行时对自动变量进行管理。常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。之所以被称为栈，是由于新数据被象征性地放在原有数据的上面（也就是说，在相邻的内存单元中，而不是在同一 个内存单元中），当程序使用完后，将其从栈中删除。

![image-20210811110310770](https://static.fungenomics.com/images/2021/08/image-20210811110310770.png)


3．寄存器变量
这旨在提高访问变量的速度。

### 9.2.3 静态持续变量

要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它；
要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用 `static` 限定符；
要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用 `static` 限定符。

![image-20210811110632232](https://static.fungenomics.com/images/2021/08/image-20210811110632232.png)

正如前面指出的，所有静态持续变量（上述示例中的`global`、 `one_file`和 `count`）在整个程序执行期间都存在。在 `funct1()` 中声明的变量 `count` 的作用域为局部，没有链接性，这意味着只能在`funct1()` 函数中使用它，就像自动变量 `llama` 一样。然而，与`llama` 不同的是，即使在 `funct1()` 函数没有被执行时，`count` 也留在内存中。`global` 和 `one_file` 的作用域都为整个文件，即在从声明位置到文件结尾的范围内都可以被使 用。具体地说，可以在 `main()`、`funct1()` 和 `funct2()` 中使用它们。由于` one_file` 的链接性为内部，因此只能在包含上述代码的文件中使用它； 由于 `global` 的链接性为外部，因此可以在程序的其他文件中使用它。

> 应少用静态外部变量，如使用最好都声明为内部连接性的静态变量。

![image-20210811111319645](https://static.fungenomics.com/images/2021/08/image-20210811111319645.png)

### 9.2.4 静态持续性、外部链接性
链接性为外部的变量通常简称为外部变量，它们的存储持续性为静 态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函 数而言都是外部的。

1．单定义规则
C++有“单定义规则”（One Definition Rule，ODR），该规则指出， 变量只能有一次定义。请注意，单定义规则并非意味着不能有多个变量的名称相同。例 如，在不同函数中声明的同名自动变量是彼此独立的，它们都有自己的 地址。

![image-20210811111827133](https://static.fungenomics.com/images/2021/08/image-20210811111827133.png)


### 9.2.5 静态持续性、内部链接性

将static限定符用于作用域为整个文件的变量时，该变量的链接性将 为内部的。在多文件程序中，内部链接性和外部链接性之间的差别很有 意义。链接性为内部的变量只能在其所属的文件中使用；但常规外部变 量都具有外部链接性，即可以在其他文件中使用。

![image-20210811112129019](https://static.fungenomics.com/images/2021/08/image-20210811112129019.png)

> 在多文件程序中，可以在一个文件（且只能在一个文件）中定义一个外部变量。使用该变量的其他文件必须使用关键字 `extern` 声明它。

可使用外部变量在多文件程序的不同部分之间共享数据；可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据（名称空间提供了另外一种共享数据的方法）。另外，如果将作用域为整个文 件的变量变为静态的，就不必担心其名称与其他文件中的作用域为整个 文件的变量发生冲突。

### 9.2.6 静态存储持续性、无链接性

这种变量是这样创建的，将static限定符用于在代码块中定义的变 量。在代码块中使用static时，将导致局部变量的存储持续性为静态的。 这意味着虽然该变量只在该代码块中可用，但它在该代码块不处于活动 状态时仍然存在。因此在两次函数调用之间，静态局部变量的值将保持 不变。（静态变量适用于再生——可以用它们将瑞士银行的秘密账号传 递到下一个要去的地方）。另外，如果初始化了静态局部变量，则程序 只在启动时进行一次初始化。以后再调用函数时，将不会像自动变量那样再次被初始化。

```Cpp
// static.cpp -- using a static local variable
#include <iostream>
// constants
const int ArSize = 10;

// function prototype
void strcount(const char * str);

int main()
{
    using namespace std;
    char input[ArSize];
    char next;

    cout << "Enter a line:\n";
    cin.get(input, ArSize);
    while (cin)
    {
        cin.get(next);
        while (next != '\n')    // string didn't fit!
            cin.get(next);      // dispose of remainder
        strcount(input);
        cout << "Enter next line (empty line to quit):\n";
        cin.get(input, ArSize);
    }
    cout << "Bye\n";
// code to keep window open for MSVC++
/*
cin.clear();
    while (cin.get() != '\n')
        continue;
    cin.get();
*/
    return 0;
}

void strcount(const char * str)
{
    using namespace std;
    static int total = 0;        // static local variable
    int count = 0;               // automatic local variable

    cout << "\"" << str <<"\" contains ";
    while (*str++)               // go to end of string
        count++;
    total += count;
    cout << count << " characters\n";
    cout << total << " characters total\n";
}
```

![image-20210811112939105](https://static.fungenomics.com/images/2021/08/image-20210811112939105.png)

注意，在这个程序中，由于数组长度为10，因此程序从每行读取的字符数都不超过 9个。另外还需要注意的是，每次函数被调用时，自动变量count都被重 置为0。然而，静态变量total只在程序运行时被设置为0，以后在两次函 数调用之间，其值将保持不变，因此能够记录读取的字符总数。

### 9.2.7 说明符和限定符

![image-20210811113430209](https://static.fungenomics.com/images/2021/08/image-20210811113430209.png)

3. 再谈const

在C++（但不是在C语言）中，`const`限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，**但`const`全局变量的链接性为内部的**。也就是说，在C++看来，全局 `const` 定义就像使用了 `static` 说明符一样。

C++修改了常量类型的规则，让程序员更轻松。例如，假设将一组 常量放在头文件中，并在同一个程序的多个文件中使用该头文件。那 么，预处理器将头文件的内容包含到每个源文件中后，所有的源文件都 将包含类似下面这样的定义：

```Cpp
const int fingers = 10;
const char *waring = "wak!";
```

如果全局const声明的链接性像常规变量那样是外部的，则根据单定 义规则，这将出错（幸亏不是）。

由于外部定义的`const`数据的链接性为内部的，因此可以在所有文件中使用相同的声明。


### 9.2.8 函数和链接性

和变量一样，函数也有链接性，虽然可选择的范围比变量小。和C 语言一样，C++不允许在一个函数中定义另外一个函数，因此所有函数 的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。在 默认情况下，函数的链接性为外部的，即可以在文件间共享。实际上， 可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义 的，不过这是可选的。**还可以使用关键字`static`将函数的链接性设置为内部的，使之只能在一个文件中使用**，但必须同时在原型和函数定义中使用该关键字。

### 9.2.9 语言链接性

在 C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的 符号名称。因此，C++编译器执行名称矫正或名称修饰（参见第8 章），为重载函数生成不同的符号名称。例如，可能将`spiff(int)`转换 为 `_spoff_i`，而将 `spiff(double，double)` 转换为 `_spiff_d_d`。这种方法被称为C++语言链接（C++ language linkage）。

### 9.2.10 存储方案和动态分配

动态内存由运算符 `new` 和 `delete` 控制，而不是由作用域和链接性规则控制。因此，**可以在一个函数中分配动态内存，而在另一个函数中将其释放**。与自动内存不同，动态内存不是LIFO，其分配和释放顺序要取决于 `new` 和 `delete` 在何时以何种方式被使用。通常，编译器使用三块独立的内存：一块用 于静态变量（可能再细分），一块用于自动变量，另外一块用于动态存 储。

## 9.3 名称空间

名称可以是变量、函数、结构体、枚举、类以及类和结构体的成员。C++标准提供了名称空间工具，以便更好地控制名称的作用域。

### 9.3.1 传统的C++名称空间

C++关于全局变量和局部变量的规则定义了一种名称空间层次。每 个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的 名称。在一个函数中声明的局部变量不会与在另一个函数中声明的局部 变量发生冲突。

![image-20210811114957087](https://static.fungenomics.com/images/2021/08/image-20210811114957087.png)

![image-20210811115021641](https://static.fungenomics.com/images/2021/08/image-20210811115021641.png)

### 9.3.2 新的名称空间特性

C++新增了这样一种功能，即通过定义一种新的声明区域来创建命 名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名 称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允 许程序的其他部分使用该名称空间中声明的东西。

名称空间可以是全局的，也可以位于另一个名称空间中，**但不能位于代码块中**。因此，在默认情况下，在名称空间中声明的名称的链接性 为外部的（除非它引用了常量）。

1．using声明和using编译指令

using声明由被限定的名称和它前面的关键字using组成：

```Cpp
using Jill::fetch;        // a using declaration
```
`using` 声明将特定的名称添加到它所属的声明区域中。例如 `main()` 中的 `using` 声明 `Jill::fetch` 将 `fetch` 添加到 `main()` 定义的声明区域中。完成该声明后，便可以使用名称 `fetch` 代替 `Jill::fetch`。


using声明使一个名称可用，而using编译指令使所有的名称都可 用。using编译指令由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符。在全局声明区域中使用using编译指令，将使该名称空间的名称全局可用。

2．using编译指令和using声明之比较

一般说来，使用`using`声明比使用`using`编译指令更安全，这是由于它只导入指定的名称。如果该名称与局部名称发生冲突，编译器将发出 指示。`using` 编译指令导入所有名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。

3．名称空间的其他特性
可以将名称空间声明进行嵌套。

![image-20210811135518193](https://static.fungenomics.com/images/2021/08/image-20210811135518193.png)

这里，flame指的是element::fire::flame。同样，可以使用下面的 using编译指令使内部的名称可用。

4．未命名的名称空间

可以通过省略名称空间的名称来创建未命名的名称空间。

该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域末尾，这与全局变量相似。然而，这种名称空间没有名称，因此不能显式地使用 `using` 编译指令或 `using` 声明来使它在其他位置都可用。也就是说，不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称。这相当于是一个链接性为内部的静态变量的替代品。

### 9.3.4 名称空间及其前途

使用名称空间的原则：

- 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量；
- 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量；
- 如果开发了一个函数库或类库，将其放在一个名称空间中；
- 仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计；
- 不要在头文件中使用 `using` 编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令 `using`，应将其放在所有预处理器编译指令 `#include` 之后；
- 导入名称时，首选使用作用域解析运算符或using声明的方法；
- 对于using声明，首选将其作用域设置为局部而不是全局。

## 9.4 总结

C++提倡在开发程序时使用多个文件。一种有效的组织策略 是，使用头文件来定义用户类型，为操纵用户类型的函数提供函数原 型；并将函数定义放在一个独立的源代码文件中。头文件和源代码文件 一起定义和实现了用户定义的类型及其使用方式。

C++的存储方案决定了变量保留在内存中的时间（储存持续性）以 及程序的哪一部分可以访问它（作用域和链接性）。

动态内存分配和释放是使用new和delete进行的，它使用自由存储区 或堆来存储数据。调用new占用内存，而调用delete释放内存。程序使用 指针来跟踪这些内存单元。

名称空间允许定义一个可在其中声明标识符的命名区域。这样做的 目的是减少名称冲突，尤其当程序非常大，并使用多个厂商的代码时。可以通过使用作用域解析运算符、using声明或using编译指令，来使名 称空间中的标识符可用。


# 第十章 对象和类

本章内容包括：

- 过程性编程和面向对象编程；
- 类概念；
- 如何定义和实现类；
- 公有类访问和私有类访问；
- 类的数据成员；
- 类方法（类成员函数）；
- 创建和使用类对象；
- 类的构造函数和析构函数；
- const 成员函数；
- this 指针；
- 创建对象数组；
- 类作用域；
- 抽象数据类型。

面向对象编程（OOP）是一种特殊的、设计程序的概念性方法，OOP的最终特性是：

- 抽象；
- 封装和数据隐藏；
- 多态；
- 继承；
- 代码的可重用性。

为了实现这些特性并将它们组合在一起，C++所做的最重要的改进 是提供了类。

## 10.1 过程性编程和面向对象编程

采用过程性编程方法时，首先考虑要遵循的步骤，然后考虑 如何表示这些数据。
如果换成一位OOP程序员，又将如何呢？首先考虑数据——不仅要 考虑如何表示数据，还要考虑如何使用数据。
用户与数据交互的方式有三种：初始化、更新和报告——这就是用户接口。

总之，采用OOP方法时，首先从用户的角度考虑对象——描述对象 所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述 后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建 出程序。

## 10.2 抽象和类

生活中充满复杂性，处理复杂性的方法之一是简化和抽象。

### 10.2.1 类型是什么

首先，倾向于根 据数据的外观（在内存中如何存储）来考虑数据类型。但是稍加思索就会 发现，也可以根据要对它执行的操作来定义数据类型。总之，指定基本类型完成了三项工作：

- 决定数据对象需要的内存数量；
- 决定如何解释内存中的位（`long` 和 `float`在内存中占用的位数相同，但将它们转换为数值的方法不同）；
- 决定可使用数据对象执行的操作或方法。

### 10.2.2 C++中的类

类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和 操纵数据的方法组合成一个整洁的包。

定义类时，一般来说，类规范由两个部分组成：

- 类声明：以数据成员的方式描述数据部分，以成员函数（称为方法）的方式描述共有接口；
- 类方法定义：描述如何类成员函数。

简单地说，类声明提供了类的蓝图，而方法定义则提供了细节。例子：

```Cpp
// stock00.h -- Stock class interface
// version 00
#ifndef STOCK00_H_
#define STOCK00_H_

#include <string>

class Stock  // class declaration
{
private:
    std::string company;
    long shares;
    double share_val;
    double total_val;
    void set_tot() { total_val = shares * share_val; }
public:
    void acquire(const std::string & co, long n, double pr);
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};    // note semicolon at the end

#endif
```

首先， C++关键字class指出这些代码定义了一个类设计。

1．访问控制

关键字 `private` 和 `public` 也是新的，它们描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但只能通过公有成员 函数（或友元函数，参见第11章）来访问对象的私有成员。

因此，公有成员函 数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏（参见图10.1）。C++还提 供了第三个访问控制关键字protected，第13章介绍类继承时将讨论该关 键字。

![image-20210811220839703](https://static.fungenomics.com/images/2021/08/image-20210811220839703.png)

类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽 象组件。**将实现细节放在一起并将它们与抽象分开被称为封装。**数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私 有部分中，就像`Stock`类对`set_tot()` 所做的那样，也是一种封装。封装的 另一个例子是，将类函数定义和类声明放在不同的文件中。

> OOP是一种编程风格，从某种程度说，它用于任何一种语言中。

数据隐藏不仅可以防止直接访问数据，还让开发者（类的用户）无需了解数据是如何被表示的。从使用类的角度看，使用哪种方 法没有什么区别。所需要知道的只是各种成员函数的功能；也就是说，需要知道成员函数接受什么样的参数以及返回什么类型的值。原则是将实现细节从接口设计中分离出来。如果以后找到了更好的、实现数据表 示或成员函数细节的方法，可以对这些细节进行修改，而无需修改程序接口，这使程序维护起来更容易。

2．控制对成员的访问：公有还是私有

无论类成员是数据成员还是成员函数，都可以在类的公有部分或私 有部分中声明它。但由于隐藏数据是OOP主要的目标之一，因此数据项 通常放在私有部分，组成类接口的成员函数放在公有部分；否则，就无 法从程序中调用这些函数。

### 10.2.3 实现类成员函数

还需要创建类描述的第二部分：为那些由类声明中的原型表示的成 员函数提供代码。成员函数定义与常规函数定义非常相似，它们有函数 头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：

- 定义成员函数时，使用作用域解析运算符 `::` 来标识函数所属的类；
- 类方法可以访问类的 `private` 组件。

例如：

```Cpp
void Stock::update(double price) {
    ....
}
```

作用域解析运算符确定了方法定义对应的类的身份。

类方法的第二个特点是，方法可以直接访问类的私有成员，**如同访问一个已经声明好的常用变量一样**。例如，show( ) 方法可以使用这样的代码：

```Cpp

void Stock::show()
{
    std::cout << "Company: " << company
              << "  Shares: " << shares << '\n'
              << "  Share Price: $" << share_val
              << "  Total Worth: $" << total_val << '\n';
}
```
其中，company、shares等都是Stock类的私有数据成员。

另外，类声明常将短小的成员函数作为内联函数在头文件中随类声明一起定义。

> 内联函数的特殊规则要求在每个使用它们的文件中都对其进行定 义。确保内联定义对多文件程序中的所有文件都可用的、最简便的方法是：**将内联定义放在定义类的头文件中**。


**所创建的每个新对象都有自己的存储空间，用于存储其内部变量和 类成员；但同一个类的所有对象共享同一组类方法，即每种方法只有一 个副本**。例如，假设 `kate` 和 `joe` 都是 `Stock` 对象，则 `kate.shares` 将占据一个 内存块，而 `joe.shares` 占用另一个内存块，但`kate.show()` 和 `joe.show()` 都调用同一个方法，也就是说，**它们将执行同一个代码块**，只是将这些代码用于不同的数据。在OOP中，调用成员函数被称为发送消息，因此将 同样的消息发送给两个不同的对象将调用同一个方法，但该方法被用于两个不同的对象。

![image-20210811222542618](https://static.fungenomics.com/images/2021/08/image-20210811222542618.png)

### 10.2.4 使用类 

使用类与使用基本的内置类型（如int和char）尽可能相同。要创建类对象，可以声明类变量，也可以使用 `new` 为类对象分配存储空间。可以将对象作为函数的参数和返回值，也可以将一个对象赋给另一个。

要使用新类型，最关键的是要了解成员函数的功能，而不必考虑 其实现细节。

### 10.2.5 修改实现

### 10.2.6 小结
指定类设计的第一步是提供类声明。类声明类似结构声明，可以包 括数据成员和函数成员。声明有私有部分，在其中声明的成员只能通过 成员函数进行访问；声明还具有公有部分，在其中声明的成员可被使用 类对象的程序直接访问。通常，数据成员被放在私有部分中，成员函数 被放在公有部分中，因此典型的类声明的格式如下：

![image-20210811223153090](https://static.fungenomics.com/images/2021/08/image-20210811223153090.png)

## 10.3 类的构造函数和析构函数

C++的目标之一是让使用类对象就像使用标准类型一样。

![image-20210811223501009](https://static.fungenomics.com/images/2021/08/image-20210811223501009.png)

一般来说，最好是在创建对象时对它进行初始化。

就Stock类当前的实现而言，gift对象的company成员是没有值的。 类设计假设用户在调用任何其他成员函数之前调用acquire( )，但无法强 加这种假设。避开这种问题的方法之一是在创建对象时，自动对它进行 初始化。为此，C++提供了一个特殊的成员函数——类构造函数，专门 用于构造新对象、将值赋给它们的数据成员。名称与类名相同。例如，Stock类一个可能的构造函数是名为Stock( )的成员函 数。**构造函数的原型和函数头有一个有趣的特征——虽然没有返回值， 但没有被声明为void类型。实际上，构造函数没有声明类型**。

```Cpp
// stock10.h <96> Stock class declaration with constructors, destructor added
#ifndef STOCK1_H_
#define STOCK1_H_
#include <string>
class Stock
{
private:
    std::string company;
    long shares;
    double share_val;
    double total_val;
    void set_tot() { total_val = shares * share_val; }
public:
    Stock();        // default constructor
    Stock(const std::string & co, long n = 0, double pr = 0.0);  // reload constructor;
    ~Stock();       // noisy destructor
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};

#endif
```
程序声明对 象时，将自动调用构造函数。


### 10.3.1 声明和定义构造函数

通常定义两个构造函数：一个默认空参数，在未提供显式初始值时，用来创建对象；另一个则提供对私有变量做初始化的参数。

```Cpp
// stock1.cpp <96> Stock class implementation with constructors, destructor added
#include <iostream>
#include "stock10.h"

// constructors (verbose versions)
Stock::Stock()        // default constructor
{
    std::cout << "Default constructor called\n";
    company = "no name";
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}

Stock::Stock(const std::string & co, long n, double pr)
{
    std::cout << "Constructor using " << co << " called\n";
    company = co;

    if (n < 0)
    {
        std::cout << "Number of shares can't be negative; "
                   << company << " shares set to 0.\n";
        shares = 0;
    }
    else
        shares = n;
    share_val = pr;
    set_tot();
}
```

### 10.3.2 使用构造函数

C++提供了两种使用构造函数来初始化对象的方式。第一种方式是 显式地调用构造函数：

```Cpp

Stock food = Stock("World Cabbage", 250, 1.25);
```

另一种方式是隐式地调用构造函数：

```Cpp
Stock garment("Furry Mason", 50, 2.5);
```
这种格式更紧凑，它与下面的显式调用等价。

```Cpp
Stock garment = Stock("Furry Mason", 50, 2.5);
```

每次创建类对象（包括使用 `new` 动态分配内存）时，C++都使用类构造函数。

```Cpp
Stock *pstock = new Stock("Electrosgock Games", 18. 19.0);
```
这条语句创建一个Stock对象，将其初始化为参数提供的值，并将 该对象的地址赋给pstock指针

**但无法使用对象来调用构造函数，因为在构造函数构造出对象之 前，对象是不存在的**。因此构造函数被用来创建对象，而不能通过对象来调用。


### 10.3.3 默认构造函数

默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，则C++将自动提供默认构造函数。它是默认构造函 数的隐式版本，不做任何工作。对于Stock类来说，默认构造函数可能 如下：

```Cpp
Stock::Stock() {};
```

当且仅当没有定义任何构造函数时，编译器才会提供默 认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造 函数。如果提供了非默认构造函数（如Stock(const char * co, int n, double pr)），但没有提供默认构造函数，则下面的声明将出错：

```Cpp
Stock stock1;   // 没有合适的构造函数用于构造对象
```

定义默认构造函数的方式有两种。一种是给已有构造函数的所 有参数提供默认值：

```Cpp
Stock(const string &co = "Error", int n=0, double pr=0);
```
另一种方式是通过函数重载来定义另一个构造函数——一个没有参 数的构造函数：

```Cpp
Stock();
```

用户定义的默认构造函数通常给所有成员提供隐式初始值。

### 10.3.4 析构函数

用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。 对象过期时，程序将自动调用一个特殊的成员函数，该函数称为析构函数。析构函数很有用，用于对象过期时的完成清理工作。例 如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放 这些内存。Stock的构造函数没有使用new，因此析构函数实际上没有需 要完成的任务。在这种情况下，只需让编译器生成一个什么要不做的隐式析构函数即可。

析构函数的名称很特殊：在类名前加上`~`。

因此，`Stock` 类的析构函数为 `~Stock()`。另外，和构造函数一样，**析构函数也可以没有返回值和声明类型。与构造函数不同的是，析构函数没有参数**，因此 `Stock` 析构函数的原型 **必须** 是这样的：

```Cpp
~Stock();
```

什么时候应调用析构函数呢？这由编译器决定，通常不应在代码中 显式地调用析构函数。如果创建的是静态存储类对象，则其析构函数将在程序结束 时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义 的）自动被调用。如果对象是通过new创建的，则它将驻留在栈内存或 自由存储区中，当使用delete来释放内存时，其析构函数将自动被调 用。最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。

### 10.3.5 改进 `Stock` 类

```Cpp
// usestok1.cpp -- using the Stock class
// compile with stock10.cpp
#include <iostream>
#include "stock10.h"

int main()
{
  {
    using std::cout;
    cout << "Using constructors to create new objects\n";
    Stock stock1("NanoSmart", 12, 20.0);            // syntax 1
    stock1.show();
    Stock stock2 = Stock ("Boffo Objects", 2, 2.0); // syntax 2
    stock2.show();

    cout << "Assigning stock1 to stock2:\n";
    stock2 = stock1;
    cout << "Listing stock1 and stock2:\n";
    stock1.show();
    stock2.show();

    cout << "Using a constructor to reset an object\n";
    stock1 = Stock("Nifty Foods", 10, 50.0);    // temp object
    cout << "Revised stock1:\n";
    stock1.show();
    cout << "Done\n";
  }
    // std::cin.get();
    return 0;
}
```

下面的语句表明可以将一个对象赋给同类型的另一个对象：

```Cpp
stock2 = stock1;
```

在默认情况下，**将一个对象赋给同类型的另一个对象时，C++将源对象的每个数据成员的内容复制到目标对象中相应的数据成员中**。

构造函数不仅仅可用于初始化新对象。例如，该程序的`main( )` 中包含下面的语句：

```Cpp
stock1 = Stock("Nifty Foods", 10, 50.0);
```
stock1对象已经存在，因此这条语句不是对stock1进行初始化，而 是将新值赋给它。这是通过让构造程序创建一个新的、临时的对象，然后将其内容复制给 `stock1` 来实现的。临时对象复制完成之后，程序调用析构函数，删除该临时对象。

![image-20210811230556935](https://static.fungenomics.com/images/2021/08/image-20210811230556935.png)

输出表明，下面两条语句有根本性的差别：

```Cpp
Stock stock2 = Stock("Boffo Objects", 2, 2.0);
stock1 = Stock("Nifty Foods", 10, 50.0);
```
**第一条语句是初始化，它创建有指定值的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值。像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象**。

> 如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式。通常这种 方式的效率更高。


6．`const` 成员函数

请看下面的代码片段：

```Cpp
const Stock land = Stock("KP", 0, 0.0);
land.show();
```
对于当前的C++来说，编译器将拒绝第二行。这是什么原因呢？因为 `show()` 的代码无法确保调用对象不被修改。

我们以前通过将函数参数声明为 `const` 引用或指向 `const` 的指针来解决这种问题。但这里存在语法问题：`show()` 方法没有任何参数。相反，它所使用的对象是由方法调用隐式地提供。

需要一种新的语法来保证函数不会修改调用对象。**C++的解决方法是将 `const` 关键字放在函数的括号后面**。也就是说，`show()` 声明应像这样：

```Cpp
void show() const;         // promise not to change invoking object
```

同样，函数定义的开头应像这样：

```Cpp
void stock::show() const {
    ...
}
```

**以这种方式声明和定义的类函数被称为 `const` 成员函数**，从而确保函数内不会修改调用对象。

### 10.3.6 构造函数和析构函数小结

构造函数是一种特殊的类成员函数，在创建类对象时被调用。构造 函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函 数，条件是每个函数的特征标（参数列表）都不同。另外，构造函数没 有声明类型。通常，构造函数用于初始化类对象的成员，初始化应与构 造函数的参数列表匹配。

默认构造函数没有参数，因此如果创建对象时没有进行显式地初始 化，则将调用默认构造函数。如果程序中没有提供任何构造函数，则编 译器会为程序定义一个默认构造函数；否则，必须自己提供默认构造函 数。默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值。

当对象被删除时，程 序将调用析构函数。每个类都只能有一个析构函数。析构函数没有返回 类型（连 `void` 都没有），也没有参数，其名称为类名称前加上 `~`。

如果构造函数使用了 `new`，则必须提供使用 `delete` 的析构函数。

## 10.4 this 指针

有时候类方法可能涉及到两个对象，在这种情况下需要使用 `this` 指针。

如何将方法的答案传回给调用程序呢？最直接的方法是让方法返回一个引用，该引用指向股价总值较高的对象。因此，用于比较的类方法 `topval` 的原型如下：

```Cpp
const Stock & topval(const Stock &s) const;
```
该函数隐式地访问一个对象，而显式地访问另一个对象，并返回其 中一个对象的引用。括号中的`const` 表明，该函数不会修改被显式地访问的对象；而括号后的 `const` 表明，该函数不会修改被隐式地访问的对象。 由于该函数返回了两个 `const` 对象之一的引用，因此返回类型也应为 `const` 引用。

比较之后，返回引用时有一个问题需要解决：

![image-20210811232755584](https://static.fungenomics.com/images/2021/08/image-20210811232755584.png)

C++解决这种问题的方法是：使用被称为 `this` 的特殊指针。`this` 指针指向用来调用成员函数的对象（`this`被作为隐藏参数传递给方法）。这样，函数调用 `stock1.topval(stock2)` 将 `this` 设置为 `stock1` 对象的地址，使得这个指针可用于 `topval()` 方法。

一般来说，所有的类方法都将 `this` 指针设置为调用它的对象的地址。而 `topval()` 中的 `total_val` 只不过是 `this->total_val` 的简写。

![image-20210811233043535](https://static.fungenomics.com/images/2021/08/image-20210811233043535.png)

```Cpp
const Stock & Stock::topval(const Stock & s) const
{
    if (s.total_val > total_val)
        return s;
    else
        return *this;
}
```

## 10.5 对象数组

声明对象数组的方法与 声明标准类型数组相同。

```Cpp
Stock mystuff[4];
```

可以用构造函数来初始化数组元素。在这种情况下，必须为每个元 素调用构造函数：

```Cpp
/ create an array of initialized objects
    Stock stocks[4] = {
        Stock("NanoSmart", 12, 20.0),
        Stock("Boffo Objects", 200, 2.0),
        Stock("Monolithic Obelisks", 130, 3.25),
        Stock("Fleep Enterprises", 60, 6.5)
    };
```

这里的代码使用标准格式对数组进行初始化：用括号括起的、以逗 号分隔的值列表。其中，每次构造函数调用表示一个值。如果类包含多 个构造函数，则可以对不同的元素使用不同的构造函数。

## 10.6 类作用域

在类中定义的名称（如类数据成员名和类成员函数名）的作用域都 为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可 知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。

总之，在类声明或成员函数定义中，可以使用未修饰的成员名称 （未限定的名称），就像`sell( )` 调用 `set_tot()` 成员函数时那样。构造函数名称在被调用时，才能被识别，因为它的名称与类名相同。在其他情况下，使用类成员名时，必须根据上下文使用直接成员运算符 ``、间接成员运算符 `->` 或作用域解析运算符 `::`。

![image-20210811235956703](https://static.fungenomics.com/images/2021/08/image-20210811235956703.png)

### 10.6.1 作用域为类的常量

有时候，使符号常量的作用域为类很有用。例如，类声明可能使用 字面值30来指定数组的长度，由于该常量对于所有对象来说都是相同 的，因此创建一个由所有对象共享的常量是个不错的主意。你以为可以这样：

```Cpp
class Bakery {
private:
	const int Months = 12;
	double costs[Months];
}
```
但**这是不行的**！！ 因为声明类只是描述了对象的形式，并没有创建对象。

C++提供了另一种在类中定义常量的方式——使用关键字 `static`：

```Cpp
class Bakery {
private:
	static const int Months = 12;
	double costs[Months];
}
```

### 10.6.2 作用域内枚举（C++11）
### 10.7 抽象数据类型
### 10.8 总结

面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使 用数据。然后，设计一个类来实现该接口。

通常，将类声明分成两部分组成，这两部分通常保存在不同的文件 中。类声明（包括由函数原型表示的方法）应放到头文件中。定义成员 函数的源代码放在方法文件中。这样便将接口描述与实现细节分开了。

**类是用户定义的类型，对象是类的实例**。

每个对象都存储自己的数据，而共享类方法。

如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要显式地引用调用它的对象，则可以使用 `this` 指针。`this` 指针被设置为调用对象的地址，因此`*this` 是该对象的别名。


# 第十一章 使用类

本章内容包括：

- 运算符重载；
- 友元函数；
- 重载 `<<` 运算符，以便用于输出；
- 状态成员；
- 使用 `rand()` 生成随机值；
- 类的自动转换和强制类型转换；
- 类转换函数。


学习C++的难点之一是需要记住大量的东西，但在拥有丰富的实践 经验之前，根本不可能全部记住这些东西。从这种意义上说，学习 C++ 就像学习功能复杂的字处理程序或电子制表程序一样。任何特性都不可怕，但多数人只掌握了那些经常使用的特性，如查找文本或设置为 斜体等。您可能在那里曾经学过如何生成替换字符或者创建目录，除非经常使用它们，否则这些技能可能根本与日常工作无关。也许，学习本 章知识的最好方法是，在我们自己开发的C++程序中使用其中的新特性。


## 11.1 运算符重载

运算符重载是一种形式的 C++ 多态。
运算符 重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。实 际上，很多C++（也包括C语言）运算符已经被重载。例如，将 `*` 运算符用于地址，将得到存储在这个地址中的值；但将它用于两个数字时，得到的将是它们的乘积。C++根据操作数的数目和类型来决定采用哪种操 作。

重载运算符可使代码看起来更自然。

要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式为：`operatorop(argument-list)`。

例如，`operator +()` 重载 `+` 运算符，`operator *()` 重载 `*` 运算符。`op` 必须是有效的C++运算符，不能虚构一个新的符号。例如，不能有 `operator@()` 这样的函数，因为C++中没有 `@` 运算符。然而，`operator` 函数可以重载 `[]` 运算符，因为 `[]` 是数组索引运算符。

## 11.2 计算时间：一个运算符重载示例

定义一个 `Time` 类:

```Cpp
// mytime0.h -- Time class before operator overloading
#ifndef MYTIME0_H_
#define MYTIME0_H_

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time Sum(const Time & t) const;
    void Show() const;
};
#endif
```

该类的定义：

```Cpp
#include <iostream>
#include "mytime0.h"

Time::Time()
{
    hours = minutes = 0;
}

Time::Time(int h, int m )
{
    hours = h;
    minutes = m;
}

void Time::AddMin(int m)
{
    minutes += m;
    hours += minutes / 60;
    minutes %= 60;
}

void Time::AddHr(int h)
{
    hours += h;
}

void Time::Reset(int h, int m)
{
    hours = h;
    minutes = m;
}

Time Time::Sum(const Time & t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}

void Time::Show() const
{
    std::cout << hours << " hours, " << minutes << " minutes";
}
```


来看一下 `Sum()` 函数的代码。注意参数是引用，但返回类型却不是 引用。将参数声明为引用的目的是为了提高效率。如果按值传递 `Time` 对象，代码的功能将相同，但传递引用，速度将更快，使用的内存将更少。

然而，返回值不能是引用。因为函数将创建一个新的Time对象 （sum），来表示另外两个Time对象的和。返回对象（如代码所做的那 样）将创建对象的副本，而调用函数可以使用它。然而，如果返回类型 为 `Time &`，则引用的将是 `sum` 对象。但由于 `sum` 对象是局部变量，在函数结束时将被删除，因此引用将指向一个不存在的对象。使用返回类型 `Time` 意味着程序将在删除 `sum` 之前构造它的拷贝，调用函数将得到该拷贝。

> 不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失， 引用将指向不存在的数据。

但这种 sum 时间的方法看起来很傻。

### 11.2.1 添加加法运算符

将Time类转换为重载的加法运算符很容易，只要将`Sum()` 的名称改为 `operator +()` 即可。

```Cpp
// mytime1.h -- Time class before operator overloading
#ifndef MYTIME1_H_
#define MYTIME1_H_

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+ (const Time & t) const;
    void Show() const;
};
#endif
```

类定义中改为：

```Cpp
// mytime1.cpp  -- implementing Time methods
#include <iostream>
#include "mytime1.h"
...
Time Time::operator+(const Time & t) const
{
    Time sum;
    sum.minutes = minutes + t.minutes;
    sum.hours = hours + t.hours + sum.minutes / 60;
    sum.minutes %= 60;
    return sum;
}
...
```

将该方法命令改为 `operator +()` 后，就可以使用运算符表示法：

```Cpp
total = coding + fixing;
```

```Cpp
// usetime1.cpp -- using the second draft of the Time class
// compile usetime1.cpp and mytime1.cpp together
#include <iostream>
#include "mytime1.h"

int main()
{
    using std::cout;
    using std::endl;
    Time planning;
    Time coding(2, 40);
    Time fixing(5, 55);
    Time total;

    total = coding + fixing;
    cout << "coding + fixing = ";
    total.Show();
    cout << endl;

    return 0;
}
```

### 11.2.2 重载限制

![image-20210812010750643](https://static.fungenomics.com/images/2021/08/image-20210812010750643.png)

多数C++运算符（参见表11.1）都可以用这样的方式重载。重载的运算符（有些例外情况）不必是成员函数，但必须至少有一个操作数是 用户定义的类型。下面详细介绍C++对用户定义的运算符重载的限制：

- 1．重载后的运算符**必须至少有一个操作数是用户定义的类型**，这将防止用户为标准类型重载运算符；
- 2．使用运算符时不能违反运算符原来的句法规则。例如不要将 `-` 重载为加法运算。同样，不能修改运算符的优先级；
- 3．不能创建新运算符。例如，不能定义 `operator **()` 函数来表示求幂；
- 4．不能重载下面的运算符：

![image-20210812010658117](https://static.fungenomics.com/images/2021/08/image-20210812010658117.png)

- 5．表11.1中的大多数运算符都可以通过成员或非成员函数进行重 载，但下面的运算符只能通过成员函数进行重载。

![image-20210812010824269](https://static.fungenomics.com/images/2021/08/image-20210812010824269.png)

### 11.2.3 其他重载运算符

还有一些其他的操作对 `Time` 类来说是有意义的。例如，可能要将两个时间相减或将时间乘以一个因子，这需要重载减法和乘法运算符。这 和重载加法运算符采用的技术相同，即创建 `operator –()` 和 `operator *()` 方法。也就是说，将下面的原型添加到类声明中：

```Cpp
Time operator- (const time & t) const;
Time operator* (double n) const;
```

修改类定义：

```Cpp
// mytime2.cpp  -- implementing Time methods
#include <iostream>
#include "mytime2.h"

...
Time Time::operator-(const Time & t) const
{
    Time diff;
    int tot1, tot2;
    tot1 = t.minutes + 60 * t.hours;
    tot2 = minutes + 60 * hours;
    diff.minutes = (tot2 - tot1) % 60;
    diff.hours = (tot2 - tot1) / 60;
    return diff;
}

Time Time::operator*(double mult) const
{
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
...
```

## 11.3 友元

通常，公有类方法提 供唯一的访问途径，但是有时候这种限制太严格，以致于不适合特定的 编程问题。在这种情况下，C++提供了另外一种形式的访问权限：友 元。友元有3种：

- 友元函数；
- 友元类；
- 友元成员函数。

通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。

需要友元的原因是为了解决这样一个问题：

![image-20210812011654884](https://static.fungenomics.com/images/2021/08/image-20210812011654884.png)

![image-20210812011808963](https://static.fungenomics.com/images/2021/08/image-20210812011808963.png)

对于非成员重载运算符函数来说，**运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数**。而原来的成员函数则按相反的顺序处理操作数，也就是说，double值乘以Time值。

使用非成员函数可以按所需的顺序获得操作数（先是double，然后 是Time），但引发了一个新问题：**非成员函数不能直接访问类的私有数据，至少常规非成员函数不能访问**。然而，有一类特殊的*非成员函数*可以访问类的私有成员，它们被称为友元函数。

### 11.3.1 创建友元

创建友元函数的第一步是将其原型放在类声明中，并在原型声明前 加上关键字 `friend`。

```Cpp
friend Time operator* (double m, const Time & t);
```

该原型意味着下面两点：

- 虽然 `operator *()` 函数是在类声明中声明的，但它不是成员函数，因 此不能使用成员运算符来调用；
- 虽然 `operator *()` 函数不是成员函数，但它与成员函数的访问权限相同。

第二步是编写函数定义。**因为它不是成员函数**，所以不要使用 `Time::` 限定符。另外，不要在定义中使用关键字 `friend`，定义应该如下：

```Cpp
Time operator*(double mult) {
    Time result;
    long totalminutes = hours * mult * 60 + minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}
```

有了上述声明和定义后，语句：`A = 2.75 * B` 就被自动转换为 `A = operator*(2.75, B)`。

总之，**类的友元函数是非成员函数，但访问权限与成员函数相同**。

### 11.3.2 常用的友元：重载 `<<` 运算符

```Cpp
// mytime3.h -- Time class with friends
#ifndef MYTIME3_H_
#define MYTIME3_H_
#include <iostream>

class Time
{
private:
    int hours;
    int minutes;
public:
    Time();
    Time(int h, int m = 0);
    void AddMin(int m);
    void AddHr(int h);
    void Reset(int h = 0, int m = 0);
    Time operator+(const Time & t) const;
    Time operator-(const Time & t) const;
    Time operator*(double n) const;
    friend Time operator*(double m, const Time & t)
        { return t * m; }   // inline definition
    friend std::ostream & operator<<(std::ostream & os, const Time & t);

};
#endif
```
代码中对 `friend Time operator*(double m, const Time & t)` 的重载定义非常棒，是一个相当聪明的做法！它不是重新写一段代码，而是调用已重载的 `Time operator*(double n) const` 成员函数。



## 11.4 重载运算符：作为成员函数还是非成员函数

一般来说，非成员函数应是友元函数，这样它才能直接访 问类的私有数据。加法运算符需要两个操作数。对于成员函数版本来说，一个操作数 通过this指针隐式地传递，另一个操作数作为函数参数显式地传递；对 于友元版本来说，两个操作数都作为参数来传递。

对于某些运算符来说（如前所述），成员函数是唯一合法的选择。在其他情况下，这两种格式没有太大的区别。有时，根据类设计，使用非成员函数版本可能更好（尤其是为类定义类型 转换时）。

## 11.5 再谈重载：一个矢量类

```Cpp
    // subtract Vector b from a
    Vector Vector::operator-(const Vector & b) const
    {
        return Vector(x - b.x, y - b.y);
    }

    // reverse sign of Vector
    Vector Vector::operator-() const
    {
        return Vector(-x, -y);
    }
```

operator-( )有两种不同的定义。这是可行的，因为它们的特征标不同（两个矢量相减，或者单个矢量取反）。可以定义−运算符的一元和二元版本，因为C++提供了该运 算符的一元和二元版本。对于只有二元形式的运算符（如除法运算符），只能将其重载为二元运算符。

> 因为运算符重载是通过函数来实现的，所以只要运算符函数的特征标不同，使用的运算符数 量与相应的内置C++运算符相同，就可以多次重载同一个运算符。

## 11.6 类的自动转换和强制类型转换
## 11.7 总结
一般来说，访问私有类成员的唯一方法是使用类方法。C++使用友 元函数来避开这种限制。要让函数成为友元，需要在类声明中声明该函 数，并在声明前加上关键字friend。

C++扩展了对运算符的重载，允许自定义特殊的运算符函数，这种 函数描述了特定的运算符与类之间的关系。运算符函数可以是类成员函数，也可以是友元函数（有一些运算符函数只能是类成员函数）。

最常见的运算符重载任务之一是定义<<运算符，使之可与cout一起 使用，来显示对象的内容。要让ostream对象成为第一个操作数，需要将 运算符函数定义为友元；要使重新定义的运算符能与其自身拼接，需要 将返回类型声明为 `ostream &`。

![image-20210812015334769](https://static.fungenomics.com/images/2021/08/image-20210812015334769.png)

然而，如果类包含这样的方法，它返回需要显示的数据成员的值， 则可以使用这些方法，无需在`operator<<()`中直接访问这些成员。在这种情况下，函数不必（也不应当）是友元。

C++允许指定在类和基本类型之间进行转换的方式。首先，任何接 受唯一一个参数的构造函数都可被用作转换函数，将类型与该参数相同 的值转换为类。如果将类型与该参数相同的值赋给对象，则C++将自动调用该构造函数。

要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。转换函数必须是成员函数。


# 第十二章 类和动态内存分配

本章内容包括：

- 对类成员使用动态内存分配；
- 隐式和显示复制构造函数；
- 隐式和显示重载赋值运算符；
- 在构造函数中使用 `new` 所必须完成的工作；
- 使用静态类成员；
- 将定位 `new` 运算符用于对象；
- 使用指向对象的指针；
- 实现队列抽象数据类型（ADT）。

对类使用 `new` 和 `delete` 将影响构造函数和析构函数的设计以及运算符的重载。

## 12.1 动态内存和类

### 12.1.1 复习示例和静态类成员

```Cpp
// strngbad.h -- flawed string class definition
#include <iostream>
#ifndef STRNGBAD_H_
#define STRNGBAD_H_
class StringBad
{
private:
    char * str;                // pointer to string
    int len;                   // length of string
    static int num_strings;    // number of objects
public:
    StringBad(const char * s); // constructor
    StringBad();               // default constructor
    ~StringBad();              // destructor
// friend function
    friend std::ostream & operator<<(std::ostream & os,
                       const StringBad & st);
};
#endif

```

对这个声明，需要注意的有两点。首先，它使用char指针（而不是 char数组）来表示姓名。这意味着类声明没有为字符串本身分配存储空 间，而是在构造函数中使用new来为字符串分配空间。这避免了在类声 明中预先定义字符串的长度。

其次，将num_strings成员声明为静态存储类。静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，`StringBad` 类的所有对象共享同一个 `num_strings`。假设创建了10个 `StringBad` 对象，将有10个 `str` 成员和10个 `len` 成员，但只有一个共享的 `num_strings` 成员（参见图12.1）。

![image-20210812100941808](https://static.fungenomics.com/images/2021/08/image-20210812100941808.png)

```Cpp
// strngbad.cpp -- StringBad class methods
#include <cstring>                    // string.h for some
#include "strngbad.h"
using std::cout;

// initializing static class member
int StringBad::num_strings = 0;

// class methods

// construct StringBad from C string
StringBad::StringBad(const char * s)
{
    len = std::strlen(s);             // set size
    str = new char[len + 1];          // allot storage
    std::strcpy(str, s);              // initialize pointer
    num_strings++;                    // set object count
    cout << num_strings << ": \"" << str
         << "\" object created\n";    // For Your Information
}

StringBad::StringBad()                // default constructor
{
    len = 4;
    str = new char[4];
    std::strcpy(str, "C++");          // default string
    num_strings++;
    cout << num_strings << ": \"" << str
         << "\" default object created\n";  // FYI
}

StringBad::~StringBad()               // necessary destructor
{
    cout << "\"" << str << "\" object deleted, ";    // FYI
    --num_strings;                    // required
    cout << num_strings << " left\n"; // FYI
    delete [] str;                    // required
}

std::ostream & operator<<(std::ostream & os, const StringBad & st)
{
    os << st.str;
    return os;
}
```

`int StringBad::num_strings = 0;` 这条语句将静态成员 `num_strings` 的值初始化为零。注意：**不能在类声明中初始化静态成员变量，这是因为类声明中只描述如何分配内存，但并不分配内存**。

可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。

另外，初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果 在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。

上述代码中，`strlen()`返回字符串长度，但不包括末尾的空字符，因此构造函数将`len`加1，使分配的内存能够存储包含空字符的字符串。

删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用delete语句可确保对象过期 时，由构造函数使用new分配的内存被释放。

> 在构造函数中使用 `new` 来分配内存时，必须在相应的析构函数中使用 `delete` 来释放内存。如果 使用 `new[]`（包括中括号）来分配内存，则应使用`delete[]`（包括中括号）来释放内存。

`StringBad`的第一个版本有许多故意留下的缺陷，是一个很糟糕的类（找到该类的错误之处，甚至可以作为一道困难的编程题），这些缺陷使得输出是不确定的。例如，有些 编译器无法编译它。虽然输出的具体内容有所差别，但基本问题和解决方法（稍后将介绍） 是相同的。

程序输出结果：

![image-20210812111740343](https://static.fungenomics.com/images/2021/08/image-20210812111740343.png)

`callme2()` 按值（而不是按引用）传递 `headline2`，结果表明这是一个严重的问题。

首先，将 `headline2` 作为函数参数来传递从而**导致析构函数被调用**。这是因为函数的参数  `sb` 是一个临时变量，当函数调用结束后会释放这个临时变量，从而导致析构函数被调用，糟糕的源头在于析构函数中恰巧就释放了字符串。 其次，虽然按值传递可以防止原始参数被修改，但实际上函数已使原始 字符串无法识别，导致显示一些非标准字符（显示的文本取决于内存中 包含的内容）。

因为自动存储对象被删除的顺序与创建顺序相反，所以最先删除的 3个对象是`knots`、`sailor`和`sport`。删除`knots`和`sailor`时是正常的，但在删 除`sport`时，`Dollars`变成了`Doll8`(或其他)。对于`sport`，程序只使用它来初始化 `sailor`，但这种操作修改了 `sports`（这又可以做一道题）。

具体而言，程序中 `Stringbad sailor = sports;` 这个语句既不是调用默认构造函数也不是调用参数为 `const char*` 的构造函数，而是等价于 `StringBad sailor=StringBad(sports);` ，又因为`sports`的类型为`StringBad`，因此与之相应的构造函数原型应该是 `StringBad(const String &);`，**但这个构造函数在`StringBad`类中没有显式声明更没有定义。这时当我们使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）**。但自动生成的复制构造函数不知道需要更新静态变量`num_string`，因此会将计数方案搞乱（这就是复制对象带来的问题）。实际上，这个例子说明的所有问题都是由编译器自动生成的成员函数引起的。

最后被删除的两个对象（`headline2`和 `headline1`）已经无法识别。


### 12.1.2 特殊成员函数

`StringBad`类的问题是由特殊成员函数引起的。这些成员函数是自动定义的，就`StringBad`而言，这些函数的行为与类设计不符。具体地说， C++自动提供了下面这些成员函数：

- 默认构造函数；
- 默认析构函数；
- 复制构造函数；
- 复制预运算符；
- 地址运算符。

更准确地说，编译器将生成上述最后三个函数的定义——如果程序 使用对象的方式要求这样做。例如，如果您将一个对象赋给另一个对 象，编译器将提供赋值运算符的定义。

结果表明，StringBad类中的问题是由隐式复制构造函数和隐式赋值运算符引起的。

1．默认构造函数

默认情况下，编译器将提供一个不接受任何参数，也不执行任何操作 的构造函数（默认的默认构造函数），这是因为创建对象时总是会调用 构造函数。

如果定义了构造函数，C++将不会定义默认构造函数。

2．复制构造函数

复制构造函数用于将一个对象复制到新创建的对象中。也就是说，**它用于初始化过程中（包括按值传递参数），而不是常规的赋值过程**（那赋值的时候怎么办？赋值靠赋值运算符=，见12.1.4），原型是：`Class_name(const Class_name &)`。它接受一个指向类对象的常量引用作为参数。

对于复制构造函数，需要知道两点：何时调用和有何功能。

3．何时调用复制构造函数

新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。 最常见的情况是将新对象显式地初始化为现有的对象。

![image-20210812120029250](https://static.fungenomics.com/images/2021/08/image-20210812120029250.png)

其中中间的2种声明可能会使用复制构造函数直接创建metoo和 also，也可能使用复制构造函数生成一个临时对象，然后将临时对象的 内容赋给metoo和also，这取决于具体的实现。最后一种声明使用motto 初始化一个匿名对象，并将新对象的地址赋给pStringBad指针。

**每当程序生成了对象副本时，编译器都将使用复制构造函数**。具体地说，当函数按值传递对象（如程序清单12.3中的 `callme2()`）或函数返回对象时，都将使用复制构造函数。记住，**按值传递意味着创建原始变量的一个副本**。编译器生成临时对象时，也将使用复制构造函数。

何时生成临时对象随编译器而异，但无论是哪种编译器，**当按值传递和返回对象时，都将调用复制构造函数**。

> 由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。


4．默认的复制构造函数的功能

默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。

![image-20210812120710195](https://static.fungenomics.com/images/2021/08/image-20210812120710195.png)

![image-20210812120946029](https://static.fungenomics.com/images/2021/08/image-20210812120946029.png)



### 12.1.3  回到 Stringbad：复制构造函数的哪里出了问题 

第一个异常，num_string是负值。当`callme2()`被调用时，复制构造函数被用来初始化 `callme2()` 的形参，还被用来将对象 `sailor` 初始化为对象 `sports`。默认的复 制构造函数不说明其行为，因此它不指出创建过程，也不增加计数器 num_strings的值。但析构函数更新了计数，并且在任何对象过期时都将 被调用，而不管对象是如何被创建的。程序的输出表明，析构函数的调用次数比构造函数的调用次数多2。

第二个异常之处更微妙，也更危险，其症状之一是字符串内容出现乱码。原因在于隐式复制构造函数是按值进行复制的。例如，对于程序清 单12.3，隐式复制构造函数的功能相当于：`sailor.str = sport.str;`。这里复制的并不是字符串，而是一个指向字符串的指针。也就是 说，将sailor初始化为sports后，得到的是两个指向同一个字符串的指 针。当operator <<()函数使用指针来显示字符串时，这并不会出现问 题。但当析构函数被调用时，这将引发问题。析构函数StringBad释放str 指针指向的内存，因此释放sailor的效果如下：

![image-20210812121546201](https://static.fungenomics.com/images/2021/08/image-20210812121546201.png)

`sports.str`指向的内存已经被 `sailor` 的析构函数释放，这将导致不确定 的、可能有害的后果。

1．定义一个显式复制构造函数以解决问题

解决类设计中这种问题的方法是进行深度复制（deep copy）。也就是说，**复制构造函数应当复制字符串并将副本的地址赋给`str`成员，而不仅仅是复制字符串地址**。这样每个对象都有自己的字符串，而不是引用 另一个对象的字符串。调用析构函数时都将释放不同的字符串，而不会试图去释放已经被释放的字符串。可以这样编写`String`的复制构造函数：

```Cpp
String::String(const char * s)     // construct String from C string
{
    len = std::strlen(s);          // set size
    str = new char[len + 1];       // allot storage
    std::strcpy(str, s);           // initialize pointer
    num_strings++;                 // set object count
}
```

![image-20210812121927440](https://static.fungenomics.com/images/2021/08/image-20210812121927440.png)

### 12.1.4 Stringbad的其他问题：赋值运算符

并不是程序清单12.3的所有问题都可以归咎于默认的复制构造函 数，还需要看一看默认的赋值运算符。C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。这种运算符 的原型如下：

```
Class_name & Class_name::operator=(const Class_name &);
```

它接受并返回一个指向类对象的引用。

1．赋值运算符的功能以及何时使用它

将已有的对象赋给另一个对象时，将使用重载的赋值运算符。初始化对象时，并不一定会使用赋值运算符，而更可能是调用复制构造函数。

```Cpp
StringBad metoo = knot; 
```
这里，`metoo` 是一个新创建的对象，被初始化为 `knot` 的值，因此使用复制构造函数。然而，正如前面指出的，实现时**也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时 对象的值复制到新对象中**。这就是说，初始化总是会调用复制构造函数，而使用 `=` 运算符时也可能调用赋值运算符。

与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制，静态成员不受影响。

2．赋值的问题出在哪里

程序清单12.3将headline1赋给knot：`knot=headline1;`。为knot调用析构函数时，正常。为Headline1调用析构函数时，异常。**出现的问题与隐式复制构造函数相同：数据受损。这也是成员复制 的问题，即导致headline1.str和knot.str指向相同的地址**。

3. 解决赋值的问

解决办法是提供赋 值运算符（进行深度复制）定义，这与复制构造函数相似，但也有 一些差别:

- 由于目标对象可能引用了以前分配的数据，所以函数应使用`delete []` 来释放这些数据；
- **函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内 存操作可能删除对象的内容**；
- 函数返回一个指向调用对象的**引用**（注意是引用，不是值也不是指针）。

```Cpp
// assign a String to a String
String & String::operator=(const String & st)
{
    if (this == &st)
        return *this;
        
    delete [] str;
    len = st.len;
    str = new char[len + 1];
    std::strcpy(str, st.str);
    return *this;
}
```

赋值操作并不创建新的对象，因此不需要调整静态数据成员 `num_strings` 的值。

## 12.2 改进后的新String类

首先，添加前面介绍过的复制构造函数和赋值运算符，使类 能够正确管理类对象使用的内存。其次，由于您已经知道对象何时被创 建和释放，因此可以让类构造函数和析构函数保持沉默，不再在每次被 调用时都显示消息。另外，也不用再监视构造函数的工作情况，因此可以简化默认构造函数，使之创建一个空字符串，而不是“C++”。

新默认构造函数中：

```Cpp
String::String()                   // default constructor
{
    len = 4;
    str = new char[1];
    str[0] = '\0';                 // default string
    num_strings++;
}
```

为什么代码为 `str=new char[1];` 而不是 `str = new char;`，这两个方式相同，但区别在于前者和类析构函数兼容，而后者不兼容。这是析构函数：

```Cpp
String::~String()                     // necessary destructor
{
    --num_strings;                    // required
    delete [] str;                    // required
}
```

对 `operator>` 的重载很妙啊，直接利用了 `operator<` 的重载结果：
![image-20210812163721949](https://static.fungenomics.com/images/2021/08/image-20210812163721949.png)



### 12.2.3 使用中括号表示法访问字符

在C++中，两个中括号组成一个运算符——中括号运算符，可以使 用方法operator 来重载该运算符。通常，二元C++运算符（带两个操作 数）位于两个操作数之间，例如2 +5。但对于中括号运算符，**一个操作数位于第一个中括号的前面，另一个操作数位于两个中括号之间**。例如：`city[0]` 中，`city`是第一个操作数，`[]`是运算符，`0`是第二个操作数。

在重载时，C++将区分常量和非常量函数的特征标。

```Cpp
    // read-write char access for non-const String
char & String::operator[](int i)
{
    return str[i];
}

    // read-only char access for const String
const char & String::operator[](int i) const
{
    return str[i];
}
```

有了上述定义后，就可以读/写常规String对象了；而对于const String对象，则只能读取其数据。

> 重载要注意同时考虑对const 和非 const 变量进行。

![image-20210812165647776](https://static.fungenomics.com/images/2021/08/image-20210812165647776.png)

也可以修改内容：

```Cpp
String means("might");
means[0] = 'r';   // 这一句相当于 means.str[0] = 'r', 但 str 是私有成员，实际是没法在成员函数之外这样使用的。
```

### 12.2.4 静态类成员函数

首先，不能通过对象调用静态成员函数；实际上，静态成员函数甚 至不能使用this指针。

其次，由于静态成员函数不与特定的对象相关联，因此只能使用静 态数据成员。

![image-20210812170316128](https://static.fungenomics.com/images/2021/08/image-20210812170316128.png)

### 12.2.5 进一步重载赋值运算符

![image-20210812170559987](https://static.fungenomics.com/images/2021/08/image-20210812170559987.png)

重载>>运算符提供了一种将键盘输入行读入到String对象中的简单 方法。它假定输入的字符数不多于String::CINLIM的字符数，并丢弃多 余的字符。在if条件下，如果由于某种原因（如到达文件尾或`get(char *, int)` 读取的是一个空行）导致输入失败，istream对象的值将置为 false。


## 12.3 在构造函数中使用new时应注意的事项

使用new初始化对象的指针成员时必须特别小心：

- 如果在构造函数中使用new来初始化指针成员，则应在析构函数中 使用delete；
- new和delete必须相互兼容。new对应于delete，new[ ]对应于delete[ ]；
- 如果有多个构造函数，则必须以相同的方式使用new，要么都带中 括号，要么都不带。因为只有一个析构函数，所有的构造函数都必 须与它兼容。然而，可以在一个构造函数中使用new初始化指针， 而在另一个构造函数中将指针初始化为空（0或C++11中的 nullptr），这是因为delete（无论是带中括号还是不带中括号）可以用于空指针；
- 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一 个对象；

![image-20210812183412719](https://static.fungenomics.com/images/2021/08/image-20210812183412719.png)

- 应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象；

![image-20210812183448925](https://static.fungenomics.com/images/2021/08/image-20210812183448925.png)

具体地说，该方法应完成这些操作：**检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用**。

### 12.3.1 应该和不应该

### 12.3.2 包含类成员的类的逐成员复制

![image-20210812185109539](https://static.fungenomics.com/images/2021/08/image-20210812185109539.png)

如果您将一个 Magazine对象复制或赋值给另一个Magazine对象，逐成员复制将使用成 员类型定义的复制构造函数和赋值运算符。也就是说，复制成员title 时，将使用String的复制构造函数，而将成员title赋给另一个Magazine对 象时，将使用String的赋值运算符，依此类推。

## 12.4 有关返回对象的说明
当成员函数或独立的函数返回对象时，有几种返回方式可供选择。 可以**返回指向对象的引用、指向对象的const引用或const对象**。

### 12.4.1 返回指向const对象的引用

![image-20210812185620612](https://static.fungenomics.com/images/2021/08/image-20210812185620612.png)

这里有三点需要说明。首先，返回对象将调用复制构造函数，而返回引用不会，所以版本2效率更高。其次，引用指向的对象应该在调用函数执行时存在。第 三，**v1和v2都被声明为const引用，因此返回类型必须为const，这样才匹配**。

### 12.4.2 返回指向非const对象的引用

两种常见的返回非 `const` 对象情形是，重载赋值运算符以及重载与 `cout` 一起使用的 `<<` 运算符。前者这样做旨在提高效率，而后者必须这样做。

Operator<<()的返回值用于串接输出：

```Cpp
String s1("Good stuff");
cout << s1 << " is comming!";
```

`operator<<（cout, s1）`的返回值成为一个用于显示字符串“is coming!”的对象。返回类型必须是 `ostream &`，而不能仅仅是 `ostream`。**如果使用返回类型`ostream`，将要求调用`ostream`类的复制构造 函数，而`ostream`没有公有的复制构造函数**。

### 12.4.3 返回对象

如果被返回的对象是**被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数**。因此，当控制权回到调用函数时，引用指向的对象将不再存在。**在这种情况下，应返回对象而不是引用**。

### 12.4.4 返回 `const` 对象

前面的Vector::operator+( )定义有一个奇异的属性，它旨在让您能够 以下面这样的方式使用它：`net = force1 + force2;`。

然而，这种定义也允许您这样使用它：

```
force1 + force2 = net;
cout << (force1 + force2 = net).magval() << endl;
```

这提出了三个问题。为何编写这样的语句？这些语句为何可行？这 些语句有何功能？**首先，没有要编写这种语句的合理理由，但并非所有代码都是合理的**。

这种代码之所以可行，是因为复制构造函数将创建一个临时 对象来表示返回值。因此，在前面的代码中，表达式force1 + force2的结 果为一个临时对象。在语句1中，该临时对象被赋给net；在语句2和3 中，net被赋给该临时对象。使用完临时对象后，将把它丢弃。

总之，如果方法或函数要返回局部对象，则应返回对象，而不是指 向对象的引用。在这种情况下，将使用复制构造函数来生成返回的对 象。如果方法或函数要返回一个没有公有复制构造函数的类（如ostream类）的对象，它必须返回一个指向这种对象的引用。最后，有些方法和 函数（如重载的赋值运算符）可以返回对象，也可以返回指向对象的引 用，在这种情况下，应首选引用，因为其效率更高。

## 12.5 使用指向对象的指针

![image-20210812215628088](https://static.fungenomics.com/images/2021/08/image-20210812215628088.png)

### 12.5.1 再谈`new`和`delete`

![image-20210812220903934](https://static.fungenomics.com/images/2021/08/image-20210812220903934.png)

### 12.5.2 指针和对象小结

- 使用常规表示法来声明指向对象的指针；
- 可以将指针初始化为指向已有的对象；
- 可以使用new来初始化指针，这将创建一个新的对象；
- 对类使用new将调用相应的类构造函数来初始化新创建的对象。

![image-20210812221115586](https://static.fungenomics.com/images/2021/08/image-20210812221115586.png)

![image-20210812221146826](https://static.fungenomics.com/images/2021/08/image-20210812221146826.png)

- 可以使用`->`运算符通过指针访问类方法；
- 可以对对象指针应用解除引用运算符`*`来获得对象。

### 12.5.3 再谈定位new运算符
## 12.6 复习各种技术
### 12.6.1 重载<<运算符

要重新定义 << 运算符，以便将它和cout一起用来显示对象的内 容，请定义下面的友元运算符函数：

![image-20210812221524669](https://static.fungenomics.com/images/2021/08/image-20210812221524669.png)

### 12.6.2 转换函数
要将单个值转换为类类型，需要创建原型如下所示的类构造函数：

```Cpp
class_name(type_name value);
```

要将类转换为其他类型，需要创建原型如下所示的类成员函数：

```
operator type_name();
```

虽然该函数没有声明返回类型，但应返回所需类型的值。

使用转换函数时要小心。可以在声明构造函数时使用关键字 explicit，以防止它被用于隐式转换。

### 12.6.3 其构造函数使用new的类

## 12.7 队列模拟

