C++总览简介

C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。
C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。
C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。
C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。

注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。

面向对象程序设计

C++最大的亮点就是面向对象程序设计理念的运用。包括面向对象开发的四大特性：
    封装
    抽象
    继承
    多态

C++的组成部分

标准的 C++ 由三个重要部分组成：
    核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。
    C++ 标准库，提供了大量的函数，用于操作文件、字符串等。
    标准模板库（STL），提供了大量的方法，用于操作数据结构等。



# 第一章 预备知识
（略）
# 第二章 开始学习 C++
（略）
C++用分号隔开每一个执行语句。
# 第三章 处理数据

**面向对象编程（OOP）的本质是设计并扩展自己的数据类型。设计自己的数据类型就是让类型与数据匹配。**

内置的C++类型分两组：基本类型和复合类型。本章将介绍基本类型，即整数和浮点数。似乎只有两种类型，但C++知道，没有任何一种整型和浮点型能够满足所有的编程要求，因此对于这两种数据，它提供 了多种变体。

## 3.1 简单变量

把信息存储在计算机中，程序必须记录3个基本属性：

* 信息将存储在哪里； 
* 要存储什么值； 
* 存储何种类型的信息。

实际上，程序将找到一块能够存储整数的内存，将该内存单元标记为braincount，并将5复制到该内存单元中；然 后，您可在程序中使用braincount来访问该内存单元。

> 可以使用&运算符来检索braincount的内存地址。

### 3.1.1 变量名

C++ 提倡使用有一定含义的变量名，并遵循几 种简单的 C++ 命名规则：

* 在名称中只能使用字母字符、数字和下划线 ( _ )；
* 名称的第一个字符不能是数字；
* 区分大写字符与小写字符；
* 不能将C++关键字用作名称；
* 以*两个下划线* 或 *下划线+大写字母* 打头的名称被保留给实现（编译器及其使用的资源）使用；
* 以 *一个下划线* 开头的名称被保留给实现，用作全局标识符；

C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。

> 倒数第二点与前面几点有些不同，因为使用像 __time_stop 或 _Donut 这样的名称不会导致编译器错误，而会导致行为的不确定性。换句话说，不知道结果将是什么。不出现编译器错误的原因是，这样的名称不 是非法的，但要留给实现使用。

![image-20210719213322578](https://static.fungenomics.com/images/2021/07/image-20210719213322578.png)

如果想用两个或更多的单词组成一个名称，通常的做法是用下划线字符将单词分开，如 my_onions (**用这类**)；或者从第二个单词开始将每个单词的第一个字母大写，如 myEyeTooth。

**在 C++ 所有主观的风格中，一致性和精度是最重要的**。请根据自己的需要、喜好和个人风格来使用变量名（或必要时，根据雇主的需要、喜好和个人风格来选择变量名）。

### 3.1.2 整型

不同C++整型使用不同的内存量来存储整数。使用的内存量越大，可以表示的整数值范围也越大。

C++的基本整型（按宽度递增的顺序排列）分别是char、short、int、long和C++11新增的long long，其中每种类型都有符号版本和无符号版本，因此总共有10种类型可供选择。

### 3.1.3 整型short、int、long和long long

C++ 的short、int、long和long long类型通过使用不同数目的位来存储值，最多能够表示4种不同的整数宽度：

* short至少16位；
* int至少与short一样长；
* long 至少32位，且至少与int一样长；
* long long至少64位，且至少与long一样长。

> 这意味着可以把16位单元设置成65 536个不同的值，把 32位单元设置成4 294 672 296个不同的值，把64位单元设置为18 446 744 073 709 551 616个不同的值。作为比较，unsigned long存储不了地球上当前的人数和银河系的星星数，而long long 能够。

当前很多系统都使用最小长度，即short为16位，long为32位。这仍然为int提供了多种选择，其宽度可以是16位、24位或32位，同时又符合标准；甚至可以是64位，因为long和long long至少长64位。

> 类型的宽度随实现而异，这可能在将C++程序从一种环境移到另一种环境（包括在同一个系统中使用不同编译器）时引发问题。

首先，sizeof运算符返回类型或变量的长度；其次，头文件climits（在老式实现中为limits.h）中包含了关于整型限制的信息。具体地说，它定义了表示各种限制的符号名称。例如，INT_MAX为int的最大取值，CHAR_BIT为字节的位数。

在我的 Macbook Air 64位 OS 上，数据类型是这样的: 

```bash
int is 4 bytes.
short is 2 bytes.
long is 8 bytes.
long long is 8 bytes.

Maximum values:
int: 2147483647
short: 32767
long: 9223372036854775807
long long: 9223372036854775807

Minimum int value = -2147483648
Bits per byte = 8
```

![image-20210719215348315](https://static.fungenomics.com/images/2021/07/image-20210719215348315.png)
![image-20210719215405073](https://static.fungenomics.com/images/2021/07/image-20210719215405073.png)

**赋值与声明合并在一起叫做初始化。**如果知道变量的初始值应该是什么，则应对它进行初始化。

如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该变量的值 将是它被创建之前，相应内存单元保存的值。

![image-20210719215954131](https://static.fungenomics.com/images/2021/07/image-20210719215954131.png)


### 3.1.4 无符号类型

要创建无符号版 本的基本整型，只需使用关键字 unsigned 来修改声明即可。注意，unsigned本身是unsigned int的缩写。

### 3.1.5 选择整型类型

通常，int被设置为对 目标计算机而言最为“自然”的长度。自然长度（natural size）指的是计 算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其 他类型，则应使用int。

如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long。即使系统上int为32位，也应这样做。这样，将程序移植到16位系统时，就不会突然无法正常工作（参见图3.2）。如果要存储的值超过20亿，可使用long long。

> 所以对于基因组数据上的位置信息，最好是 long 类型咯，即便 unsigned int 类型已经足够。（不过我可能还是希望用 unsigned int ）

![image-20210719220858422](https://static.fungenomics.com/images/2021/07/image-20210719220858422.png)

如果short比int小，则使用short可以节省内存。通常，仅当有大型整 型数组时，才有必要使用short。如果只需要一个字节，可使用char。

### 3.1.6 整型字面值

整型字面值（常量）是显式地书写的常量，如212或1776。

> 诸如cout<<hex;等代码不会在屏幕上显示任何内容，而只是修改 cout显示整数的方式。因此，控制符hex实际上是一条消息，告诉cout采 取何种行为。另外，由于标识符hex位于名称空间std中，而程序使用了 该名称空间，因此不能将hex用作变量名。然而，如果省略编译指令 using，而使用std::cout、std::endl、std::hex和std::oct，则可以将hex用作 变量名。

### 3.1.7 C++如何确定常量的类型

![image-20210719221757664](https://static.fungenomics.com/images/2021/07/image-20210719221757664.png)

### 3.1.8 char类型：字符和小整数

char类型是专为存 储字符（如字母和数字）而设计的。

char类型是另一种整型。实际上，很多系统支持的字符都不超过128个，因此用一个字节就可以表示所有的符号。因此，虽然char最常被用来处理字符，但也可以 将它用做比short更小的整型。

C++对字符用单引号，对字符串使用双引号。 cout对象能够处理这两种情况，但正如第4章将讨论的，这两者有天壤之别）。

与int不同的是，char在默认情况下既不是没有符号，也不是有符号。是否有符号由C++实现决定，这样编译器开发人员可以最大限度地将这种类型与硬件属性匹配起来。如果char有某种特定的行为对您来说 非常重要，则可以显式地将类型设置为signed char 或unsigned char。

如果将char用作数值类型，则unsigned char和signed char之间的差异将非常重要。unsigned char类型的表示范围通常为0～255，而signed char 的表示范围为−128到127。

> 例如，假设要使用一个char变量来存储像200这样大的值，则在某些系统上可以，而在另一些系统上可能不可以。但 使用unsigned char可以在任何系统上达到这种目的。

如果大型字符 集是实现的基本字符集(如中文日文系统)，则编译器厂商可以将char定义为一个16位的字节或更长的字节。其次，一种实现可以同时支持一个小型基本字符集和 一个较大的扩展字符集。8位char可以表示基本字符集，另一种类型 wchar_t（宽字符类型）可以表示扩展字符集。wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类 型与另一种整型（底层（underlying）类型）的长度和符号属性相同。对底层类型的选择取决于实现，因此在一个系统中，它可能是unsigned short，而在另一个系统中，则可能是int。



## 3.2 const 限定符

C++有一种比 `#define` 更好的处理符号常量的方法，这种方法就是使用 const 关键字来修改变量声明和初始化。

```Cpp
const int Months = 12;
```
常量（如Months）被初始化后，其值就被固定 了，编译器将不允许再修改该常量的值。如果您这样做，g++将指出程 序试图给一个只读变量赋值。关键字const叫做限定符，因为它限定了声 明的含义。

> #define 定义符号常量的方式应抛弃。

一种常见的做法是将名称的首字母大写，以提醒您Months是个常量。这决不是一种通用约定，但在阅读程序时有助于区分常量和变量。另一种约定是将整个名称大写，使用#define创建常量时通常使用这种约定。

**注意：** 如果在声明常量时没有提供值，则该常量的值将是不确定的，且无 法修改。

## 3.3 浮点数

使用浮点类型可以表示诸如2.5、3.14159和122442.32这样的数字，即带小数部分的数字。计算机将这样的值分成两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。下面打个比方。对于数字34.1245和34124.5，它们除了小数点的位置不同外，其他都是相同的。 可以把第一个数表示为0.341245（基准值）和100（缩放因子），而将第二个数表示为0.341245（基准值相同）和10000（缩放因子更大）。缩放因子的作用是移动小数点的位置，术语浮点因此而得名。C++内部表示浮点数的方法与此相同，只不过它基于的是二进制数，因此缩放因 子是2的幂，不是10的幂。

### 3.3.1 书写浮点数

C++有两种书写浮点数的方式：
* 第一种是使用常用的标准小数点表示法；
* 第二种表示浮点值的方法叫做E表示法，其外观是像这样的： 3.45E6，这指的是3.45与1000000相乘的结果；E6指的是10的6次方，即 1后面6个0。因此，3.45E6表示的是3450000，6被称为指数，3.45被称为 尾数。

![image-20210719225234354](https://static.fungenomics.com/images/2021/07/image-20210719225234354.png)

E表示法确保数字以浮点格式存储，即使没有小数点。注意，既可 以使用E也可以使用e，指数可以是正数也可以是负数，不要有空格。

![image-20210719224852195](https://static.fungenomics.com/images/2021/07/image-20210719224852195.png)

> 电子的质量是 9.11e-31 kg 表示 0.000000000000000000000000000000911 kg， 而美国报警电话 911 竟然很巧合地与此相同。

### 3.3.2 浮点类型

C++也有3种浮点类型：float、double 和 long double。

事实上，C和C++对于有效位数的要求是，float至少32位，double至少48位，且不少于float，long double至少和double一样多。这三种类型的有效位数可以一样多。然而，通常，float为32位，double为64位， long double为80、96或128位。另外，这3种类型的指数范围至少是−37到37。可以从头文件cfloat或float.h中找到系统的限制。

### 3.3.3 浮点常量

在默认情况下，像8.24和2.4E8这样的浮点常量都属于double类型。如果希望常量为float类型，请使用f或F后缀。对于long double类型，可使用l或L后缀（由于l看起来像数字1，因此L是更好的选择）。

### 3.3.4 浮点数的优缺点

与整数相比，浮点数有两大优点。首先，可以表示整数之间的 值。其次，由于有缩放因子，它们可以表示的范围大得多。另一方面， **浮点运算的速度通常比整数运算慢，且精度将降低**。

如: 2.34E+22是一个小数点左边有23位的数字。加上1，就 是在第23位加1。但float类型只能表示数字中的前6位或前7位，因此修改第23位对这个值不会有任何影响。

## 3.4 C++算术运算符

![image-20210719230134697](https://static.fungenomics.com/images/2021/07/image-20210719230134697.png)

`11.17 + 50.25` 应等于61.42，但是输出的却是61.419998。这不是运算问题，而是由于float类型表示有效位数的能力有限。记住，对于float，C++只保证6位有效位。如果将 61.419998四舍五入成6位，将得到61.4200，这是在保证精度下的正确值，如果用double 则精度足够，所以直接可以获得 61.42 的值。

> 通常来说 double 都比 float 更精准，应尽量使用 double。

### 3.4.1 运算符优先级和结合性

算术运算符遵 循通常的代数优先级，先乘除，后加减。

### 3.4.2 除法分支

除法运算符（/）的行为取决于操作数的类型。如果两个操作数都 是整数，则C++将执行整数除法。这意味着结果的小数部分将被丢弃， 使得最后的结果是一个整数。**如果其中有一个（或两个）操作数是浮点 值，则小数部分将保留，结果为浮点数**。

![image-20210719230953958](https://static.fungenomics.com/images/2021/07/image-20210719230953958.png)

**浮点常量在默认情况下为 double类型。**

### 3.4.3 求模运算符

求模运算符返回整数除法的余数。它与整数除 法相结合，尤其适用于解决要求将一个量分成不同的整数单元的问题。

### 3.4.4 类型转换

由于有11种整型和3种浮点类型，因此计算机需 要处理大量不同的情况，C++自动执行很多类型转换：

* 将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进 行转换； 
* 表达式中包含不同的类型时，C++将对值进行转换；
* 将参数传递给函数时，C++将对值进行转换。

C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将 被转换为接收变量的类型。例如，假设so_long的类型为long，thirty的类 型为short。

将一个值赋给值取值范围更大的类型通常不会导致什么问题。如，将short值赋给long变量并不会改变这个值，只是占用的字节更多而 已。然而，将一个很大的long值（如2111222333）赋给float变量将降低 精度。因为float只有6位有效数字，因此这个值将被四舍五入为 2.11122E9。因此，有些转换是安全的，有些则会带来麻烦。

![image-20210719232005071](https://static.fungenomics.com/images/2021/07/image-20210719232005071.png)

如下的报错是一个可能:

![image-20210719232233106](https://static.fungenomics.com/images/2021/07/image-20210719232233106.png)

将0赋给bool变量时，将被转换为false；而非零值将被转换为true。

当同一个表达式中包含两种不同的算术类型时，将出现什么情况 呢？在这种情况下，C++将执行两种自动转换：首先，一些类型在出现 时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时 将被转换。

* 在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int。具体地说，true被转换为1，false 被转换为0。这些转换被称为整型提升（integral promotion）。

![image-20210719232513015](https://static.fungenomics.com/images/2021/07/image-20210719232513015.png)

> int 是一种最自然的类型，运算速度也最快，要主用。

* 同样，wchar_t被提升成为下列类型中第一个宽度足够存储wchar_t 取值范围的类型：int、unsigned int、long或unsigned long。

* 将不同类型进行算术运算时，也会进行一些转换，例如将int和float 相加时。**当运算涉及两种类型时，较小的类型将被转换为较大的类型。**

![image-20210719232833549](https://static.fungenomics.com/images/2021/07/image-20210719232833549.png)

* 传递参数时的类型转换通常由C++函数原型控制。
* C++还允许通过强制类型转换机制显式地进行类型转换。强制类型转换 的格式有两种。如下：

![image-20210719233243273](https://static.fungenomics.com/images/2021/07/image-20210719233243273.png)

![image-20210719233319788](https://static.fungenomics.com/images/2021/07/image-20210719233319788.png)

**新格式的想法 是，要让强制类型转换就像是函数调用。这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。**

更安全的转换方式是使用 `static_cast<typeName> (value)` 函数。

Stroustrup认为，C语言式的强制类型转换由于有过多的可能性而极 其危险，这将在第15章更深入地讨论。运算符 `static_cast<>` 比传统强制 类型转换更严格。

### 3.4.5 C++11中的auto声明

在初始化声明中，如果 使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成 与初始值相同。

![image-20210719234008239](https://static.fungenomics.com/images/2021/07/image-20210719234008239.png)

![image-20210719234059088](https://static.fungenomics.com/images/2021/07/image-20210719234059088.png)

## 3.5 总结

C++的基本类型分为两组：一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。整型之间通过存储值时使用的内存量及有无符号来区分。整型从最小到最大依次是：bool、char、signed char、 unsigned char、short、unsigned short、int、unsigned int、long、unsigned long以及C++11新增的long long和unsigned long long。还有一种wchar_t 类型，它在这个序列中的位置取决于实现。C++11新增了类型char16_t 和char32_t，它们的宽度足以分别存储16和32位的字符编码。C++确保了char足够大，能够存储系统基本字符集中的任何成员，而wchar_t则可以存储系统扩展字符集中的任意成员，short至少为16位，而int至少与short一样长，long至少为32位，且至少和int一样长。确切的长度取决于 实现。

浮点类型可以表示小数值以及比整型能够表示的值大得多的值。3种浮点类型分别是float、double和long double。C++确保float不比double 长，而double不比long double长。通常，float使用32位内存，double使用 64位，long double使用80到128位。

对变量赋值、在运算中使用不同类型、使用强制类型转换时，C++将把值从一种类型转换为另一种类型。





# 第四章 复合类型

本章需要掌握的内容为:

- 创建和使用数组；
- 创建和使用C-风格字符串；
- 创建和使用 string 类字符串；
- 使用方法 getline() 和 get() 读取字符串；
- 混合输入字符串和数字；
- 创建和使用结构体；
- 创建和使用共用体；
- 创建和使用枚举类型；
- 创建和使用指针；
- 使用 new 和 delete 管理动态内存；
- 创建动态数组；
- 创建动态结构；
- 自动存储、静态存储和动态存储；
- vector 和 array 类简介。

## 4.1 数组

数组（array) 是一种数据格式，能够存储多个**同类型**的值。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。

> 即一个数组所在的内存区域是连续的。

要创建数组，可使用声明语句。数组声明应指出以下三点： 

- 存储在每个元素中的值的类型； 
- 数组名； 
- 数组中的元素数。

在C++中，通过在简单变量后面添加中括号（其中包含 元素数目）来完成数组声明。而数组中的每一个元素都看作是一个简单变量。声明数组的通用格式为 : 

`typeName arrayName[arraySize]`

表达式arraySize指定元素数目，它必须是整型常数（如10）或const 值，也可以是常量表达式（如8 * sizeof（int）），即其中所有的值在编 译时都是已知的。具体说，arraySize不能是变量，变量的值是在程序 运行时设置的。如：

```Cpp
int months[12];   // 声明一个包含 12 个整数的数组
```

C++ 通过使用下标来访问数组中的每一个元素，C++ 数据从0开始编号，数组总长度-1 是最后一个元素，如上：months[0] 为第一个元素，months[11] 是最后一个元素。

![image-20210721153711828](https://static.fungenomics.com/images/2021/07/image-20210721153711828.png)

### 4.1.1 

C++可以在声明语句中初始化数组，只需提供一个用逗号分隔的值列表（初始化列表），并将它们用花 括号括起即可。如 ：

```Cpp
int yamcosts[3] = {20, 30, 5};
```
如果没有初始化数组的值，则其元素值将是不确定的，这意味着元素的值为以前驻留在该内 存单元中的值。

> 将sizeof运算符用于数组名，得到的将是整个数组 中的字节数。

### 4.1.2 数组的初始化规则

只有在定义数组时才能使用初始化，此后就不能使用了，也不能将一个数组赋给另一个数组：

![image-20210721154858602](https://static.fungenomics.com/images/2021/07/image-20210721154858602.png)

> 这个方式和 Python 完全不同，原因可能是 Python 以引用为基础赋值，C++此处则是值赋值，只能一个一个来（声明时除外）。

但此后，仍然可以通过下标分别给数组中的元素赋值。注意，**这里是赋值不再是初始化**。

初始化数组时，提供的值可以少于数组的元素数目，编译器将把其他元素设置为 0。因此，将数组中所有的元素都初始化为0非常简单—只要显式地将第 一个元素初始化为0，然后编译器会自动将其他元素都初始化为0。

*还有一种方法，如果初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个 数。但这是很糟糕的做法，不提倡，不举例。*

### 4.1.3 C++11数组初始化方法

数组以前就可使用列表初始化， 但C++11中的列表初始化新增了一些功能。

- 首先，初始化数组时，可省略等号（=）；
- 其次，可不在大括号内包含任何东西，这将把所有元素都设置为零；
- 第三，列表初始化禁止缩窄转换。

![image-20210721160721085](https://static.fungenomics.com/images/2021/07/image-20210721160721085.png)

在上述代码中，第一条语句不能通过编译，因为将浮点数转换为整 型是缩窄操作，即使浮点数的小数点后面为零。第二条语句也不能通过 编译，因为1122011超出了char变量的取值范围（这里假设char变量的长 度为8位）。第三条语句可通过编译，因为虽然112是一个int值，但它在 char变量的取值范围内。

## 4.2 字符串

字符串是存储在内存的一片连续字节中的一系列字符，这里的**连续**是重点。
存储在连续字节中的一系列字符意味着可以将字符串存储在char数 组中，其中每个字符都位于自己的数组元素中。字符串提供了一种存储 文本信息的便捷方式。本章介绍两种处理字符串的方法：（1）C-风格字符串；（2）基于 string 类的方法。

C-风格字符串具有 一种特殊的性质：以空字符（null character）结尾，空字符被写作 \0， 其ASCII码为0，用来标记字符串的结尾。

![image-20210721161457763](https://static.fungenomics.com/images/2021/07/image-20210721161457763.png)

这两个数组都是char数组，但只有第二个数组是字符串，空字符对 C-风格字符串而言至关重要。C++有很多处理字符串的函数，其 中包括cout使用的那些函数。它们都逐个地处理字符串中的字符，直到 到达空字符为止。如果使用cout显示上面的cat这样的字符串，则将显示 前7个字符，发现空字符后停止。使用cout显示上面的dog数 组（它不是字符串），cout将打印出数组中的8个字母，并接着将内存 中随后的各个字节解释为要打印的字符，直到遇到空字符为止（因此不加空字符是C-风格字符串中极其危险的行为）。

有一种更好的、 将字符数组初始化为字符串的方法—只需使用一个用引号括起的字符串 即可，这种字符串被称为字符串常量（string constant）或字符串字面值 （string literal），如下所示：

![image-20210721162122919](https://static.fungenomics.com/images/2021/07/image-20210721162122919.png)

用引号括起来的字符串**隐式**地包括结尾的空字符，因此不用显式地包括它。

最需要注意的是，**使用C-风格字符串，在确定存储字符串所需的最短数组时，别忘了+1，要将结尾的空字符计算在内**。

![image-20210721162704816](https://static.fungenomics.com/images/2021/07/image-20210721162704816.png)

![image-20210721162840015](https://static.fungenomics.com/images/2021/07/image-20210721162840015.png)

> 这里的赋值改为：`char shirt_size[2] = "S";`  才是正确的。

### 4.2.1 拼接字符串常量

事实上，任何两个由空 白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。 因此，下面所有的输出语句都是等效的：

![image-20210721163221414](https://static.fungenomics.com/images/2021/07/image-20210721163221414.png)

注意，拼接时不会在被连接的字符串之间添加空格，第二个字符串 的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后 面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。

### 4.2.2 在数组中使用字符串

从程序清单4.2中可以学到什么呢？
首先，sizeof运算符指出整个数组的长度：15字节，但 strlen( )函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。
另外，strlen( ) 只计算可见的字符，而不把空字符计算在内。因此，对于Basicman，返回的值为8，而不是 9。如果cosmic是字符串，则要存储该字符串，数组的长度不能短于strlen（cosmic）+1。
由于name1和name2是数组，所以可以用索引来访问数组中各个字符。例如，该程序使用 name1[0]找到数组的第一个字符。另外，该程序将name2[3]设置为空字符。这使得字符串在第 3个字符后即结束，虽然数组中还有其他的字符（参见图4.3）。

![image-20210721164300455](https://static.fungenomics.com/images/2021/07/image-20210721164300455.png)

程序清单 4.2 使用 cin 暗含两个问题:

- 遇到空格结束；
- 输入字符串长于目标数组。

### 4.2.3 字符串输入

cin是如何确定已完成字符串输入呢？由于不能通过键盘输入空字 符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白 （空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在 获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串 放到数组中，并自动在结尾添加空字符。

这个例子的实际结果是，cin把Alistair作为第一个字符串，并将它 放到name数组中。这把Dreeb留在输入队列中。当cin在输入队列中搜索 用户喜欢的甜点时，它发现了Dreeb，因此cin读取Dreeb，并将它放到 dessert数组中。

![image-20210721171126781](https://static.fungenomics.com/images/2021/07/image-20210721171126781.png)

另一个问题是，输入字符串可能比目标数组长（运行中没有揭示出 来）。像这个例子一样使用cin，确实不能防止将包含30个字符的字符 串放到20个字符的数组中的情况发生。

文章将这个问题的系统处理留到第 17 章，但下文也能解决。

### 4.2.4 每次读取一行字符串输入

每次读取一个单词通常不是最好的选择。具体地说，需要采用面向行而不是面向单词的方法。istream中的类（如 cin）提供了一些面向行的类成员函数：`getline()` 和 `get()`。这两个函数都读取一 行输入，直到到达换行符（回车符）。区别是，`getline()` 将读入并丢弃换行符，而 `get()` 则将换行符保留在输入队列中。**注意是还保留在输入流里，没有被读走！**

1．面向行的输入：getline( )

getline( )函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。通过 `cin.getline()` 调用。该函数有两个参数，第一个参数是存储输入行的数组名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符或者碰到换行符为止，并自动在结尾处添加空字符。如：

```Cpp
cin.getline(array_name, 20);
```

例子程序清单 4.4:

![image-20210722004651618](https://static.fungenomics.com/images/2021/07/image-20210722004651618.png)

![image-20210722004809212](https://static.fungenomics.com/images/2021/07/image-20210722004809212.png)

2．面向行的输入：get( )

`iostream` 中的 `get()` 虽然和 `getline()` 类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但 get 将换行符保留在输入队列中，假设我们连续两次 调用 `get( )` 那么要注意了。

第一次调用后，换行符将被留在输入队列中，因此第二次调用时看到的第一个字符便是换行符，此时 `get()` 以为已经到达行尾了，而没有发现任何可读取的内容。**如果不借助于帮助，`get()` 将不能跨过该换行符**。

这时要用 `get()` 的另一种变体——不带任何参数，可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。例子：

![image-20210722005755295](https://static.fungenomics.com/images/2021/07/image-20210722005755295.png)

由于 `cin.get(name, ArSize)` 返回的还是 cin 对象，因此还可以合并起来调用：

```Cpp
cin.get(name, ArSize).get();  // 这样也能同时将末尾的换行符读走
```
但风险就是，**假如 ArSize 小于一行的字符数，那么调用 `get()` 后就会发生字符丢失**。

`getline()` 成员函数也同样可以合并调用连续读取字符串：

```Cpp
cin.getline(name1, ArSize).getline(name2, ArSize);
```

这语句将把输入中 连续的两行分别读入到数组name1和name2 中，其效果与两次调用 `cin.getline()` 相同。

为什么要使用 `get()`，而不是 `getline()` 呢？
首先，老式实现没有 `getline()`。其次，`get()` 使输入更仔细。例如，假设用`get( )` 将一行读入数组中。**如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？** （getline，判断不了）， 查看下一个输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入。

总之， `getline()` 使用起来简单一些，但 `get( )` 使得检查错误更简单些。

3．空行和其他问题

当 `getline()` 或 `get()` 读取空行时，将发生什么情况？最初的做法是， 下一条输入语句将在前一条 `getline()` 或 `get()` 结束读取的位置开始读取； 但当前的做法是，当 `get()`（不是getline）读取空行后将设置失效位 （failbit）。这意味着接下来的输入将被阻断，要用 `cin.clear()` 的命令来恢复输入。

另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则 `getline()` 和 `get()` 将把余下的字符留在输入队列中，`getline()` 还会设置失效位，并关闭后面的输入。

### 4.2.5 混合输入字符串和数字

![image-20210722012337405](https://static.fungenomics.com/images/2021/07/image-20210722012337405.png)

清单程序4.6 的一个问题是：
当cin读取年份，将回 车键生成的换行符留在了输入队列中。后面的cin.getline( )看到换行符 后，将认为是一个空行，并将一个空字符串赋给address数组。解决之道 是，在读取地址之前先读取并丢弃换行符。这可以通过几种方法来完 成，其中包括使用没有参数的get( )和使用接受一个char参数的get( )。

也可以利用表达式cin>>year返回cin对象，将调用拼接起来：

```Cpp
(cin >> year).get();  // or (cin >> year).get(ch);
```

## 4.3 string 类简介

`string` 类包含于头文件 `string` 并位于名称空间 `std` 中，使用起来比字符数组简单，它提供了将字符串作为一种数据类型的表示方法，符合 C++ 的风格。
string 类定义隐藏了字符串的数组性质，让我们能够像处理普通变量那样处理字符串。

在很多方面，使用 string 对象的方式和使用字符数组相同：

- 可以使用 C-风格字符串来初始化 string 对象；
- 可以使用 cin 来将键盘输入存储到 string 对象中；
- 可以使用 cout 来显示 string 对象；
- 可以使用数组表示法来访问存储在 string 对象中的字符。

string 对象和字符数组的主要区别是，可以将 string 对象声明为简单变量，而不是数组。

类设计让程序能够自动处理string的大小。例如，str1的声明创建一 个长度为0的 string 对象，但程序将输入读取到str1中时，将自动调整 str1 的长度。

这使得与使用数组相比，使用string对象更方便，也更安全。从理论上说，可以将char 数组视为一组用于存储一个字符串的 char 存储单元，而 string 类变量是一个表示字符串的实体。

###  4.3.1 C++11字符串初始化

![image-20210722141823630](https://static.fungenomics.com/images/2021/07/image-20210722141823630.png)

### 4.3.2 string 赋值、拼接和附加

string 可以如简单变量那般操作。比如，虽然不能将一个数组赋给另一个数组，但却可以将一个 string 对象赋给另一个 string 对象。

![image-20210722142110617](https://static.fungenomics.com/images/2021/07/image-20210722142110617.png)

可以使用运算符 + 将两个string 对象合并起来，还可以使用运算符 += 将字符串附加到string对象的末尾。

```Cpp
string str1 = "aa";
string str2 = "bb";
string str3;

str3 = str1 + str2;  // 正确
str3 += str1;        // 正确
str3 += " cc";       // 一样正确
```

### 4.3.3 string类的其他操作

处理string对象的语法通常比使用C字符串函数简单，尤其是执行较 为复杂的操作时。例如，对于下述操作：

`str3 = str1 + str2;`

使用C-风格字符串时，需要使用的函数如下：

```Cpp
strcpy(charr3, charr1);
strcat(charr3, charr2);
```

`strcpy()` 和  `strcat()` 函数包含在头文件 cstring 中。函数 `strcpy()` 将字符串复制到字符数组中，使用函数 `strcat()` 将字符串附加到字符数组末尾。
另外，使用字符数组时，**总是存在目标数组过小，无法存储指定信息的危险**。

![image-20210722143658095](https://static.fungenomics.com/images/2021/07/image-20210722143658095.png)

函数strcat( )试图将全部12个字符复制到数组site中，这将覆盖相邻的内存。这可能导致程序终止，或者程序继续运行，但数据被损坏。** string类具有自动调整大小的功能，从而能够避免这种问题发生**。

### 4.3.4 string类I/O

![image-20210722144341278](https://static.fungenomics.com/images/2021/07/image-20210722144341278.png)

在用户输入之前，该程序指出数组charr中的字符串长度为27，这比 该数组的长度要大。这里要两点需要说明。首先，为初始化的数组的内 容是未定义的；其次，函数strlen( )从数组的第一个元素开始计算字节 数，直到遇到空字符。在这个例子中，在数组末尾的几个字节后才遇到 空字符。对于未被初始化的数据，第一个空字符的出现位置是随机的， 因此您在运行该程序时，得到的数组长度很可能与此不同。

用户输入之前，str中的字符串长度为0。这是因为未被初始化的string对象的长度被自动设置为0。 **这是和字符串数组不同的地方**。

源代码中是将一行输入读取到string对象中的代码是：`getline(cin, str);`。这个 `getline()` 不是类方法，它将 cin 作为参数，指出去哪里查找输入，另外，也没有指出字符串长度 的参数，因为 `string` 对象将根据字符串的长度自动调整自己的大小。

### 4.3.5 其他形式的字符串字面值

除char类型外，C++还有类型wchar_t；而C++11新 增了类型char16_t和char32_t。可创建这些类型的数组和这些类型的字符 串字面值。对于这些类型的字符串字面值，C++分别使用前缀L、u和U 表示，下面是一个如何使用这些前缀的例子：

![image-20210722162656588](https://static.fungenomics.com/images/2021/07/image-20210722162656588.png)

C++11还支持Unicode字符编码方案UTF-8。
C++11新增的另一种类型是原始（raw）字符串，并使用前缀 R 来标识，原始字符表示的就是自己，例如，序列 `\n` 不表示换行符，而表示两个常 规字符—斜杠和n，因此在屏幕上显示时，将显示这两个字符。

## 4.4 结构体简介

**结构体（Struct）**是 一种比数组更灵活的数据格式，因为同一个结构体可以存储多种不同类型的数据，从而将数据的表示合并到一起。

> 原文称 struct 为 “结构”，我认为这不符合一贯以来的称呼，因此在这个笔记中我一律改为通常在 `C/C++` 中所称呼的 “结构体”。

结构体是用户定义的类型，而结构体声明定义了这种类型的数据属性。结构体的定义需要用 关键字 **struct** 做标识。 定义了类型后，便可以创建这种类型的变量。以下例子是一个结构体的定义，它使用了一个适合用于存储字符串的 char数组、一个float和一个double。列表中的每一项都被称为结构体成员，因此 infatable 结构体有3个成员（参见图4.6）

![image-20210722163912443](https://static.fungenomics.com/images/2021/07/image-20210722163912443.png)

定义之后就可以将这个结构体当做常规的 C++ 数据类型（如同 int、double、string等）来使用。

在结构体类型中，可以通过使用成员运算符 `.` 来访问各个成员。

### 4.4.1 在程序中使用结构体

结构声明的位置很重要。

![image-20210722165020076](https://static.fungenomics.com/images/2021/07/image-20210722165020076.png)

结构体的初始化方式和数组一样，使用逗号分隔值列表，并将这些值用花括号括起。如:

![image-20210722165157045](https://static.fungenomics.com/images/2021/07/image-20210722165157045.png)

花括号中每个值可以独占一行，也可以将他们都放在同一行中，注意变量之间有逗号隔开就行，其他的随意。

### 4.4.2 C++11 结构体初始化

![image-20210722165537179](https://static.fungenomics.com/images/2021/07/image-20210722165537179.png)

### 4.4.3 结构体可以将string类作为成员吗?

可以，只要编译器支持 string 类型就没问题，唯一要注意的问题注意添加名字空间 std 。 如:

![image-20210722165802188](https://static.fungenomics.com/images/2021/07/image-20210722165802188.png)

### 4.4.4 其他结构属性

结构体和 C++ 内置类型的用法类似，它可以作为参数传递给函数，也可以让函数返回一个结构体。另外，**还可以使用赋值运算符（=）将结构体赋给另一个同类型的结构体**，这样结构体中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值（memberwise assignment）。

结构体类型还可以同时完成定义结构体和创建结构体变量的工作，只需将变量名放在结束括号的后面即可：

![image-20210722170446818](https://static.fungenomics.com/images/2021/07/image-20210722170446818.png)

但不推荐这样做，将结构体定义和变量声明分开，可以使程序更易于阅读和理解。

### 4.4.5 结构体数组

创建结构体数组的方法和创建 C++ 基本类型的数组完全相同。

要初始化结构体数组，可以使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构体的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。由于数组中的每个 元素都是结构，因此可以使用结构初始化的方式来提供它的值。

![image-20210722170912740](https://static.fungenomics.com/images/2021/07/image-20210722170912740.png)

## 4.5 共用体

共用体（union），也叫联合体是一种数据格式，它能够存储不同的数据类型， 但只能同时存储其中的一种类型。也就是说，结构体可以同时存储 int、 long和double，共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。如：

![image-20210722171406230](https://static.fungenomics.com/images/2021/07/image-20210722171406230.png)

**共用体每次只能存储一个值**，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的。

共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省内存空间，其实对当前内存充裕的计算机来说，并非很有必要使用共用体。

## 4.6 枚举

这也是一个很少用的类型，略。
![image-20210722171825483](https://static.fungenomics.com/images/2021/07/image-20210722171825483.png)

## 4.7 指针和自由存储空间

